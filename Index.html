<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Editor Vaca LoLa - Versi√≥n Profesional</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="css/main.css">
  <script src="js/colorControls.js"></script>
  <script src="js/colorControlsFixed.js"></script>
  <script src="js/lightroomColorSystem.js"></script>
  <script src="js/chatbotConfig.js"></script>
  <script src="js/chatbotUtils.js"></script>
  <script src="js/chatbot.js"></script>
  <script type="module" src="js/main.js"></script>
  <style>
    :root {
      /* Adobe-inspired Professional Color Palette */
      --bg-primary: #1a1a1a;
      --bg-secondary: #2a2a2a;
      --bg-tertiary: #3a3a3a;
      --bg-panel: #242424;
      --bg-input: #1e1e1e;
      --bg-hover: #404040;
      --border-primary: #4a4a4a;
      --border-secondary: #5a5a5a;
      --border-accent: #6a6a6a;
      --text-primary: #e8e8e8;
      --text-secondary: #b8b8b8;
      --text-muted: #888888;
      --text-disabled: #666666;
      --accent-blue: #0066cc;
      --accent-blue-hover: #0052a3;
      --accent-orange: #ff6600;
      --accent-green: #00cc66;
      --accent-red: #cc0000;
      --accent-purple: #6600cc;
      --shadow-panel: 0 2px 8px rgba(0, 0, 0, 0.4);
      --shadow-button: 0 1px 3px rgba(0, 0, 0, 0.3);
      --shadow-input: inset 0 1px 3px rgba(0, 0, 0, 0.4);
      --radius-sm: 2px;
      --radius-md: 4px;
      --radius-lg: 6px;
      --transition-fast: all 0.1s ease;
      --transition-smooth: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      --font-mono: 'SF Mono', 'Monaco', 'Cascadia Code', monospace;
    }
    *, *::before, *::after { 
      box-sizing: border-box; 
      margin: 0;
      padding: 0;
    }
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      background: linear-gradient(135deg, var(--bg-primary) 0%, #161616 100%);
      color: var(--text-primary);
      font-size: 13px;
      line-height: 1.4;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      overflow: hidden;
      user-select: none;
    }
    * {
      resize: none !important;
    }
    .page-header {
      height: 60px;
      padding: 0 24px;
      background: linear-gradient(180deg, var(--bg-secondary) 0%, var(--bg-panel) 100%);
      border-bottom: 1px solid var(--border-primary);
      box-shadow: var(--shadow-panel);
      display: flex;
      align-items: center;
      justify-content: space-between;
      position: relative;
      z-index: 100;
    }
    .page-header::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, transparent, var(--border-accent), transparent);
    }
    .header-actions {
      display: flex;
      align-items: center;
      gap: 16px;
    }
    .workspace-info {
      font-size: 10px;
      color: var(--text-muted);
    }
    .main-wrap {
      height: calc(100vh - 60px);
      display: grid;
      grid-template-columns: 320px 1fr 360px;
      grid-template-rows: 1fr;
      gap: 2px;
      background: var(--border-primary);
      overflow: hidden;
      cursor: default;
    }
    .main-wrap * {
      cursor: default;
    }
    @media (max-width: 1400px) {
      .main-wrap { grid-template-columns: 300px 1fr; }
      .tools-panel { display: none; }
    }
    @media (max-width: 1000px) {
      .main-wrap { grid-template-columns: 1fr; }
      .controls-panel, .tools-panel { display: none; }
    }
    h1 {
      font-size: 18px;
      font-weight: 700;
      color: var(--text-primary);
      letter-spacing: 0.5px;
      text-transform: uppercase;
      display: flex;
      align-items: center;
      position: relative;
      font-family: 'Inter', sans-serif;
    }
    h1::before {
      content: '';
      position: absolute;
      left: -12px;
      top: 50%;
      transform: translateY(-50%);
      width: 4px;
      height: 20px;
      background: linear-gradient(180deg, var(--accent-blue) 0%, var(--accent-purple) 100%);
      border-radius: 2px;
    }
    h1::after {
      content: 'PROFESSIONAL';
      position: absolute;
      top: 100%;
      left: 0;
      font-size: 8px;
      font-weight: 400;
      color: var(--text-muted);
      letter-spacing: 1px;
      margin-top: 2px;
    }

    h2 {
      font-size: 14px;
      margin: 0;
      font-weight: 500;
      color: var(--text-primary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .section-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 12px 16px;
      background: var(--bg-tertiary);
      border-bottom: 1px solid var(--border-primary);
      margin: 0 -16px 16px -16px;
    }
    .section-icon {
      width: 14px;
      height: 14px;
      color: var(--accent-blue);
      opacity: 0.8;
    }
    .panel {
      background: var(--bg-panel);
      border-right: 1px solid var(--border-primary);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }
    .controls-panel {
      background: var(--bg-panel);
      border-right: 1px solid var(--border-primary);
      display: flex;
      flex-direction: column;
      height: calc(100vh - 60px);
      overflow: hidden;
    }
    .controls-panel-content {
      padding: 12px;
      overflow-y: auto;
      flex: 1;
      scrollbar-width: none;
      width: 100%;
    }
    .controls-panel-content::-webkit-scrollbar {
      width: 0px;
      background: transparent;
    }
    .controls-panel-content::-webkit-scrollbar,
    .tools-panel-content::-webkit-scrollbar {
      width: 8px;
    }
    .controls-panel-content::-webkit-scrollbar-track,
    .tools-panel-content::-webkit-scrollbar-track {
      background: var(--bg-secondary);
      border-radius: 4px;
    }
    .controls-panel-content::-webkit-scrollbar-thumb,
    .tools-panel-content::-webkit-scrollbar-thumb {
      background: var(--border-secondary);
      border-radius: 4px;
      border: 2px solid var(--bg-secondary);
    }
    .controls-panel-content::-webkit-scrollbar-thumb:hover,
    .tools-panel-content::-webkit-scrollbar-thumb:hover {
      background: var(--border-accent);
    }
    .preview-panel {
      background: var(--bg-secondary);
      display: flex;
      flex-direction: column;
      position: relative;
      cursor: default;
    }
    .preview-panel::before,
    .preview-panel::after {
      content: '';
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      background: transparent;
      pointer-events: none;
      z-index: 10;
    }
    .preview-panel::before {
      left: -2px;
    }
    .preview-panel::after {
      right: -2px;
    }
    .tools-panel {
      position: relative;
    }
    .tools-panel::before {
      content: '';
      position: absolute;
      top: 0;
      bottom: 0;
      left: -5px;
      width: 5px;
      background: transparent;
      pointer-events: none;
      z-index: 100;
      cursor: default !important;
    }
    .preview-content {
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 0;
      overflow-y: auto;
      height: calc(100vh - 60px);
      scrollbar-width: none;
    }
    .preview-content::-webkit-scrollbar {
      width: 0px;
      background: transparent;
    }
    .preview-content::-webkit-scrollbar {
      width: 8px;
    }
    .preview-content::-webkit-scrollbar-track {
      background: var(--bg-secondary);
      border-radius: 4px;
    }
    .preview-content::-webkit-scrollbar-thumb {
      background: var(--border-secondary);
      border-radius: 4px;
      border: 2px solid var(--bg-secondary);
    }
    .preview-content::-webkit-scrollbar-thumb:hover {
      background: var(--border-accent);
    }
    .tools-panel {
      background: var(--bg-panel);
      display: flex;
      flex-direction: column;
      height: calc(100vh - 60px);
      overflow: hidden;
    }
    .tools-panel-content {
      padding: 12px;
      overflow-y: auto;
      flex: 1;
      scrollbar-width: none;
      width: 100%;
    }
    .tools-panel-content::-webkit-scrollbar {
      width: 0px;
      background: transparent;
    }

    .compact-section {
      margin-bottom: 12px;
      border: 1px solid var(--border-primary);
      border-radius: var(--radius-md);
      overflow: hidden;
      background: var(--bg-tertiary);
      flex-shrink: 0;
    }
    .compact-section h3 {
      font-size: 11px;
      margin: 0;
      padding: 8px 12px;
      font-weight: 500;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.8px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-primary);
    }
    .compact-section-content {
      padding: 10px;
      width: 100%;
    }
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      background: linear-gradient(180deg, var(--accent-blue) 0%, #0052a3 100%);
      border: 2px solid #0080ff;
      padding: 8px 14px;
      border-radius: var(--radius-sm);
      color: white;
      font-weight: 400;
      font-size: 12px;
      cursor: pointer;
      text-align: center;
      white-space: nowrap;
      transition: var(--transition-fast);
      box-shadow: var(--shadow-button), 0 0 0 1px rgba(0, 128, 255, 0.3);
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }
    .btn:hover {
      background: linear-gradient(180deg, var(--accent-blue-hover) 0%, #003d7a 100%);
      border-color: #00aaff;
      transform: translateY(-1px);
      box-shadow: 0 2px 6px rgba(0, 102, 204, 0.4), 0 0 0 1px rgba(0, 170, 255, 0.5);
    }
    .btn:active {
      transform: translateY(0);
      box-shadow: var(--shadow-button);
    }
    .btn.secondary {
      background: linear-gradient(180deg, var(--bg-tertiary) 0%, var(--bg-secondary) 100%);
      border: 2px solid var(--border-accent);
      color: var(--text-secondary);
      box-shadow: var(--shadow-button), 0 0 0 1px rgba(106, 106, 106, 0.3);
    }
    .btn.secondary:hover {
      background: linear-gradient(180deg, var(--bg-hover) 0%, var(--bg-tertiary) 100%);
      border-color: #8a8a8a;
      color: var(--text-primary);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(138, 138, 138, 0.4);
    }
    .btn.danger {
      background: linear-gradient(180deg, var(--accent-red) 0%, #a30000 100%);
      border: 2px solid #ff3333;
      color: white;
      box-shadow: var(--shadow-button), 0 0 0 1px rgba(255, 51, 51, 0.3);
    }
    .btn.danger:hover {
      background: linear-gradient(180deg, #e60000 0%, var(--accent-red) 100%);
      border-color: #ff5555;
      box-shadow: 0 2px 6px rgba(204, 0, 0, 0.4), 0 0 0 1px rgba(255, 85, 85, 0.4);
    }
    .btn > svg {
      width: 12px;
      height: 12px;
      opacity: 0.9;
    }
    .btn-icon {
      padding: 6px;
      min-width: 28px;
      min-height: 28px;
    }
    .btn-group {
      display: flex;
      gap: 1px;
      border-radius: var(--radius-sm);
      overflow: hidden;
      box-shadow: var(--shadow-button);
    }
    .btn-group .btn {
      border-radius: 0;
      border-right: none;
      box-shadow: none;
    }
    .btn-group .btn:last-child {
      border-right: 2px solid #0080ff;
    }
    .btn-group .btn.secondary:last-child {
      border-right: 2px solid var(--border-accent);
    }
    .text-sm {
      font-size: 12px;
      color: var(--text-muted);
    }
    .text-xs {
      font-size: 11px;
      color: var(--text-muted);
    }
    pre {
      white-space: pre-wrap;
      color: var(--text-muted);
      background-color: var(--bg-tertiary);
      padding: 12px;
      border-radius: var(--radius-sm);
      max-height: 150px;
      overflow: auto;
      border: 1px solid var(--border-light);
      font-size: 11px;
    }
    input[type=text], input[type=password], textarea, select {
      width: 100%;
      padding: 8px 10px;
      border-radius: var(--radius-sm);
      border: 1px solid var(--border-primary);
      background: var(--bg-input);
      color: var(--text-primary);
      transition: var(--transition-fast);
      font-size: 12px;
      box-shadow: var(--shadow-input);
    }
    input:focus, textarea:focus, select:focus {
      border-color: var(--accent-blue);
      outline: none;
      box-shadow: var(--shadow-input), 0 0 0 2px rgba(0, 102, 204, 0.2);
      background: var(--bg-secondary);
    }
    select {
      cursor: pointer;
      background-image: url('data:image/svg+xml;charset=US-ASCII,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 4 5"><path fill="%23888888" d="M2 0L0 2h4zm0 5L0 3h4z"/></svg>');
      background-repeat: no-repeat;
      background-position: right 6px center;
      background-size: 8px;
      padding-right: 20px;
    }
    textarea {
      min-height: 60px;
      resize: vertical;
      font-family: inherit;
    }
    details {
      border: 1px solid var(--border); border-radius: var(--radius-sm); background-color: var(--panel);
      margin-top: 12px; transition: background-color 0.2s;
    }
    details[open] { background-color: var(--bg-med); }
    summary {
      display: flex; align-items: center;
      padding: 12px 16px; font-weight: 500; cursor: pointer;
      list-style: none;
    }
    summary::before {
      content: '‚ñ∂'; display: inline-block; margin-right: 10px;
      transform: rotate(0deg); transition: transform 0.2s; font-size: 10px;
    }
    details[open] > summary::before { transform: rotate(90deg); }
    .details-content { padding: 0 16px 16px 16px; }
    fieldset { border: none; padding: 0; margin: 0; display: grid; gap: 12px; }
    label.block { display: block; margin-bottom: -4px; font-weight: 500; }
    .flex-group { display: flex; gap: 10px; align-items: center; }
    .mt-1 { margin-top: 8px; } .mt-2 { margin-top: 16px; }
    
    /* Professional Sliders */
    .sliders-container {
      display: flex;
      flex-direction: column;
      gap: 1px;
    }
    .slider-row {
      display: grid;
      grid-template-columns: 85px 1fr 45px 26px;
      align-items: center;
      gap: 8px;
      background: var(--bg-input);
      padding: 6px 10px;
      border-bottom: 1px solid var(--border-primary);
      transition: var(--transition-fast);
      min-height: 34px;
    }
    .slider-row:hover {
      background: var(--bg-hover);
    }
    .slider-row:first-child {
      border-top-left-radius: var(--radius-sm);
      border-top-right-radius: var(--radius-sm);
    }
    .slider-row:last-child {
      border-bottom-left-radius: var(--radius-sm);
      border-bottom-right-radius: var(--radius-sm);
      border-bottom: none;
    }
    .slider-row .reset-btn {
      width: 26px;
      height: 26px;
      border-radius: var(--radius-sm);
      background: var(--bg-secondary);
      border: 1px solid var(--border-secondary);
      color: var(--text-muted);
      cursor: pointer;
      transition: var(--transition-fast);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      opacity: 0.7;
      flex-shrink: 0;
    }
    .slider-row .reset-btn:hover {
      background: var(--accent-blue);
      border-color: var(--accent-blue);
      color: white;
      opacity: 1;
      transform: scale(1.1);
    }
    .slider-row .label {
      font-weight: 400;
      color: var(--text-secondary);
      cursor: pointer;
      font-size: 11px;
      text-transform: capitalize;
      letter-spacing: 0.2px;
      user-select: none;
      width: 85px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .slider-row .label:hover {
      color: var(--text-primary);
    }
    .slider-row .value {
      text-align: center;
      color: var(--text-primary);
      font-variant-numeric: tabular-nums;
      background: var(--bg-secondary);
      padding: 3px 6px;
      border-radius: var(--radius-sm);
      border: 1px solid var(--border-primary);
      font-size: 11px;
      font-family: var(--font-mono);
      width: 45px;
      box-shadow: var(--shadow-input);
    }
    input[type=range] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 4px;
      background: linear-gradient(90deg, var(--border-primary) 0%, var(--border-secondary) 50%, var(--border-primary) 100%);
      border-radius: 2px;
      outline: none;
      cursor: pointer;
      position: relative;
    }
    
    /* Sliders de color profesionales estilo Lightroom */
    .color-slider-row input[type=range] {
      height: 8px;
      border-radius: 4px;
      border: 1px solid #2a2a2a;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
      position: relative;
      overflow: hidden;
    }
    
    .color-slider-row input[type=range]::-webkit-slider-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: linear-gradient(135deg, #ffffff 0%, #e0e0e0 100%);
      border: 2px solid #333;
      box-shadow: 0 2px 6px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.3);
      cursor: pointer;
      -webkit-appearance: none;
    }
    
    .color-slider-row input[type=range]:hover::-webkit-slider-thumb {
      background: linear-gradient(135deg, #f5f5f5 0%, #d0d0d0 100%);
      transform: scale(1.1);
    }
    
    .color-slider-row input[type=range]:active::-webkit-slider-thumb {
      background: linear-gradient(135deg, #e0e0e0 0%, #c0c0c0 100%);
      transform: scale(1.05);
      box-shadow: 0 1px 3px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.2);
    }
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: linear-gradient(135deg, var(--accent-blue) 0%, var(--accent-blue-hover) 100%);
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid var(--bg-panel);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4), 0 0 0 1px var(--border-secondary);
      transition: var(--transition-fast);
    }
    input[type=range]:hover::-webkit-slider-thumb {
      background: linear-gradient(135deg, #0080ff 0%, var(--accent-blue) 100%);
      transform: scale(1.1);
      box-shadow: 0 2px 6px rgba(0, 102, 204, 0.4), 0 0 0 1px var(--accent-blue);
    }
    input[type=range]:active::-webkit-slider-thumb {
      transform: scale(1.2);
      box-shadow: 0 0 0 3px rgba(0, 102, 204, 0.3);
    }
    input[type=range]::-moz-range-thumb {
      width: 12px;
      height: 12px;
      background: var(--accent-blue);
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid var(--bg-panel);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
    }
    
    .canvas-container {
      position: relative;
      flex: 1;
      min-height: 500px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg-panel);
      border: none;
      border-radius: 0;
      overflow: hidden;
      margin: 0;
      width: 100%;
      box-sizing: border-box;
      cursor: grab;
      contain: layout style paint;
    }
    
    .canvas-container.zoomed {
      cursor: grab;
      overflow: auto;
      scroll-behavior: smooth;
    }
    
    .canvas-container::-webkit-scrollbar {
      width: 12px;
      height: 12px;
    }
    
    .canvas-container::-webkit-scrollbar-track {
      background: var(--bg-secondary);
      border-radius: 6px;
    }
    
    .canvas-container::-webkit-scrollbar-thumb {
      background: var(--border-secondary);
      border-radius: 6px;
      border: 2px solid var(--bg-secondary);
      transition: background 0.2s ease;
    }
    
    .canvas-container::-webkit-scrollbar-thumb:hover {
      background: var(--border-accent);
    }
    #canvas {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      border-radius: var(--radius-sm);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4), 0 0 0 1px var(--border-secondary);
      border: 1px solid var(--border-accent);
      position: relative;
      z-index: 1;
      transform-origin: center;
      backface-visibility: hidden;
      transform-style: preserve-3d;
      image-rendering: high-quality;
      image-rendering: -webkit-optimize-contrast;
    }
    .overlay-histogram {
      position: absolute;
      top: 12px;
      right: 12px;
      background: rgba(26, 26, 26, 0.8);
      backdrop-filter: blur(8px);
      border: 2px solid var(--border-accent);
      border-radius: var(--radius-sm);
      width: 160px;
      height: 100px;
      z-index: 10;
      opacity: 0.7;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.6);
      image-rendering: -webkit-optimize-contrast;
      image-rendering: crisp-edges;
      pointer-events: none;
    }

    .status-bar {
      text-align: center;
      color: var(--text-muted);
      font-size: 11px;
      padding: 8px;
      background: var(--bg-tertiary);
      border-radius: var(--radius-sm);
      border: 1px solid var(--border-primary);
      font-family: var(--font-mono);
    }
    .action-bar {
      display: flex;
      gap: 12px;
      justify-content: center;
      padding: 8px;
      background: var(--bg-tertiary);
      border-radius: var(--radius-sm);
      border: 1px solid var(--border-primary);
    }
    
    /* Presets */
    .preset-list {
      margin-top: 12px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      max-height: 200px;
      overflow-y: auto;
      padding: 4px;
    }
    .preset-item {
      display: grid;
      grid-template-columns: auto 1fr auto auto;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-radius: var(--radius-sm);
      background-color: var(--bg-secondary);
      border: 1px solid var(--border-light);
      transition: var(--transition);
    }
    .preset-item:hover {
      background-color: var(--bg-tertiary);
      border-color: var(--border-medium);
    }
    .preset-item .preset-name {
      flex: 1;
      font-weight: 500;
      color: var(--text-secondary);
      font-size: 13px;
    }
    .preset-item input[type=checkbox] {
      width: 16px;
      height: 16px;
      accent-color: var(--accent-primary);
    }
    .preset-item .btn {
      padding: 4px 8px;
      font-size: 11px;
    }

    /* --- ESTILOS DEL CHATBOT EMPRESARIAL --- */
    .ai-toggle-btn {
      position: fixed;
      bottom: 24px;
      right: 24px;
      z-index: 1000;
      width: 56px;
      height: 56px;
      border-radius: var(--radius-lg);
      background: linear-gradient(135deg, var(--accent-blue) 0%, var(--accent-blue-hover) 100%);
      border: 3px solid #0080ff;
      color: white;
      font-size: 20px;
      cursor: pointer;
      box-shadow: var(--shadow-lg), 0 0 0 2px rgba(0, 128, 255, 0.4);
      transition: var(--transition-smooth);
    }
    .ai-toggle-btn:hover {
      background: linear-gradient(135deg, #0080ff 0%, var(--accent-blue) 100%);
      border-color: #00aaff;
      transform: translateY(-2px);
      box-shadow: 0 12px 20px -4px rgba(0, 128, 255, 0.6), 0 0 0 2px rgba(0, 170, 255, 0.6);
    }
    
    .chat-modal {
      position: fixed;
      bottom: 90px;
      right: 24px;
      z-index: 999;
      width: 400px;
      height: 520px;
      max-height: calc(100vh - 120px);
      background: var(--bg-secondary);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-lg);
      display: none;
      flex-direction: column;
      overflow: hidden;
    }
    .chat-modal.show {
      display: flex;
      animation: slideUp 0.2s ease-out;
    }
    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(16px) scale(0.95);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }
    
    .chat-header {
      padding: 16px 20px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-light);
      color: var(--text-primary);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .chat-header h3 {
      margin: 0;
      font-size: 15px;
      font-weight: 600;
      color: var(--text-primary);
    }
    .chat-close {
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 18px;
      cursor: pointer;
      padding: 4px;
      border-radius: var(--radius-sm);
      transition: var(--transition);
    }
    .chat-close:hover {
      background: var(--bg-tertiary);
      color: var(--text-secondary);
    }
    
    #chatContainer {
      display: flex;
      flex-direction: column;
      height: 100%;
    }
    #chatMessages {
      flex-grow: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 20px;
      background: var(--bg-tertiary);
      display: flex;
      flex-direction: column;
      gap: 12px;
      scrollbar-width: none;
      max-height: calc(100% - 120px);
    }
    #chatMessages::-webkit-scrollbar {
      width: 0px;
      background: transparent;
    }
    #chatMessages::-webkit-scrollbar {
      width: 4px;
    }
    #chatMessages::-webkit-scrollbar-track {
      background: transparent;
    }
    #chatMessages::-webkit-scrollbar-thumb {
      background: var(--border-medium);
      border-radius: 2px;
    }
    .chat-message {
      max-width: 80%;
      padding: 12px 16px;
      border-radius: var(--radius-md);
      line-height: 1.5;
      word-wrap: break-word;
      font-size: 13px;
    }
    .user-message {
      background: var(--accent-primary);
      color: white;
      align-self: flex-end;
      border-bottom-right-radius: 4px;
    }
    .bot-message {
      background: var(--bg-secondary);
      color: var(--text-primary);
      align-self: flex-start;
      border-bottom-left-radius: 4px;
      border: 1px solid var(--border-light);
    }
    .recommendation-message {
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-hover));
      color: white;
      align-self: flex-start;
      border-bottom-left-radius: 4px;
      border: 1px solid var(--accent-primary);
    }
    .action-buttons {
      display: flex;
      gap: 8px;
      margin-top: 12px;
      flex-wrap: wrap;
    }
    .action-btn {
      padding: 6px 12px;
      border: none;
      border-radius: var(--radius-sm);
      font-size: 12px;
      cursor: pointer;
      transition: var(--transition);
      font-weight: 500;
    }
    .action-btn.primary {
      background: var(--success);
      color: white;
    }
    .action-btn.primary:hover {
      background: #059669;
    }
    .action-btn.secondary {
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      border: 1px solid var(--border-medium);
    }
    .action-btn.secondary:hover {
      background: var(--border-light);
      color: var(--text-primary);
    }
    .typing-indicator {
      align-self: flex-start;
      color: var(--text-muted);
      padding: 12px 16px;
      background: var(--bg-secondary);
      border-radius: var(--radius-md);
      border-bottom-left-radius: 4px;
      border: 1px solid var(--border-light);
    }
    .typing-indicator span {
      display: inline-block;
      width: 4px;
      height: 4px;
      background-color: var(--text-muted);
      border-radius: 50%;
      margin: 0 2px;
      animation: bounce 1.4s infinite ease-in-out;
    }
    .typing-indicator span:nth-child(2) {
      animation-delay: -0.2s;
    }
    .typing-indicator span:nth-child(3) {
      animation-delay: -0.4s;
    }
    @keyframes bounce {
      0%, 80%, 100% {
        transform: scale(0);
        opacity: 0.5;
      }
      40% {
        transform: scale(1.0);
        opacity: 1;
      }
    }
    #chatInputArea {
      display: flex;
      gap: 8px;
      padding: 16px 20px;
      background: var(--bg-secondary);
      border-top: 1px solid var(--border-light);
    }
    #chatInput {
      flex: 1;
      padding: 10px 14px;
      border-radius: var(--radius-md);
      border: 1px solid var(--border-medium);
      background: var(--bg-tertiary);
      transition: var(--transition);
      font-size: 13px;
    }
    #chatInput:focus {
      border-color: var(--accent-primary);
      outline: none;
      box-shadow: 0 0 0 3px var(--accent-light);
    }
    #chatSendBtn {
      padding: 10px 16px;
      border-radius: var(--radius-md);
      background: var(--accent-primary);
      border: none;
      color: white;
      cursor: pointer;
      transition: var(--transition);
    }
    #chatSendBtn:hover {
      background: var(--accent-hover);
    }
    /* --- FIN ESTILOS CHATBOT --- */

    /* --- ESTILOS CURVAS TONALES PROFESIONALES --- */
    .curves-container {
      position: relative;
      overflow: hidden;
    }
    .curves-container:hover #curveInfo {
      opacity: 1 !important;
    }
    #curvesCanvas {
      transition: var(--transition);
    }
    #curvesCanvas:hover {
      border-color: var(--accent-primary);
    }
    .curve-preset-btn {
      transition: var(--transition-fast);
      border: 2px solid var(--border-accent) !important;
      background: var(--bg-tertiary) !important;
      color: var(--text-secondary) !important;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2), 0 0 0 1px rgba(106, 106, 106, 0.2) !important;
    }
    .curve-preset-btn:hover {
      background: var(--bg-hover) !important;
      color: var(--text-primary) !important;
      border-color: #8a8a8a !important;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(138, 138, 138, 0.4) !important;
    }
    .curve-preset-btn.active {
      background: linear-gradient(180deg, var(--accent-blue) 0%, #0052a3 100%) !important;
      color: white !important;
      border: 2px solid #0080ff !important;
      box-shadow: 0 2px 6px rgba(0, 102, 204, 0.4), 0 0 0 1px rgba(0, 128, 255, 0.3) !important;
    }
    /* --- FIN ESTILOS CURVAS --- */
    
    /* Animaciones profesionales */
    @keyframes slideInUp {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    .animate-slide-in {
      animation: slideInUp 0.3s ease;
    }
    
    .animate-pulse {
      animation: pulse 2s infinite;
    }
    
    /* Tooltips profesionales */
    [title]:hover::after {
      content: attr(title);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: var(--bg-tertiary);
      color: var(--text-primary);
      padding: 4px 8px;
      border-radius: var(--radius-sm);
      font-size: 10px;
      white-space: nowrap;
      z-index: 1000;
      border: 1px solid var(--border-secondary);
      box-shadow: var(--shadow-panel);
    }
    
    /* Animaciones suaves para cambios de color */
    .color-slider-row input[type="range"] {
      transition: all 0.1s ease;
    }
    
    .color-slider-row .value {
      transition: all 0.2s ease;
    }
    
    .color-slider-row:hover .value {
      background: var(--bg-hover);
      border-color: var(--border-accent);
    }

    /* Control de Colores estilo Lightroom - Mejorado */
    .color-selector {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .color-tabs {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 2px;
      background: var(--bg-input);
      border-radius: var(--radius-sm);
      padding: 2px;
    }
    .color-tab {
      padding: 6px 8px;
      border: none;
      background: transparent;
      color: var(--text-muted);
      font-size: 10px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      cursor: pointer;
      border-radius: var(--radius-sm);
      transition: var(--transition-fast);
      text-align: center;
    }
    .color-tab:hover {
      background: var(--bg-hover);
      color: var(--text-secondary);
    }
    .color-tab.active {
      background: var(--accent-blue);
      color: white;
      box-shadow: 0 1px 3px rgba(0, 102, 204, 0.4);
      transform: translateY(-1px);
    }
    .color-sliders-container {
      display: flex;
      flex-direction: column;
      gap: 1px;
      background: var(--bg-input);
      border-radius: var(--radius-sm);
      overflow: hidden;
    }
    .color-slider-row {
      display: grid;
      grid-template-columns: 60px 1fr 35px 20px;
      align-items: center;
      gap: 8px;
      background: var(--bg-input);
      padding: 4px 8px;
      border-bottom: 1px solid var(--border-primary);
      transition: var(--transition-fast);
      min-height: 28px;
    }
    .color-slider-row:hover {
      background: var(--bg-hover);
    }
    .color-slider-row:last-child {
      border-bottom: none;
    }
    .color-slider-row .label {
      font-weight: 400;
      color: var(--text-secondary);
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.3px;
      user-select: none;
    }
    .color-slider-row .value {
      text-align: center;
      color: var(--text-primary);
      font-variant-numeric: tabular-nums;
      background: var(--bg-secondary);
      padding: 2px 4px;
      border-radius: var(--radius-sm);
      border: 1px solid var(--border-primary);
      font-size: 10px;
      font-family: var(--font-mono);
      width: 35px;
    }
    .color-slider-row .reset-btn {
      width: 20px;
      height: 20px;
      border-radius: var(--radius-sm);
      background: var(--bg-secondary);
      border: 1px solid var(--border-secondary);
      color: var(--text-muted);
      cursor: pointer;
      transition: var(--transition-fast);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 9px;
      opacity: 0.7;
    }
    .color-slider-row .reset-btn:hover {
      background: var(--accent-blue);
      border-color: var(--accent-blue);
      color: white;
      opacity: 1;
      transform: scale(1.1);
    }
    
    /* Mejoras visuales para controles de color */
    .color-tab {
      transition: all 0.2s ease;
      position: relative;
    }
    
    .color-tab:hover {
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    .color-tab.active::after {
      content: '';
      position: absolute;
      bottom: -2px;
      left: 50%;
      transform: translateX(-50%);
      width: 80%;
      height: 2px;
      background: var(--accent-blue);
      border-radius: 1px;
    }
    
    .color-sliders-container {
      border: 1px solid var(--border-primary);
      border-radius: var(--radius-sm);
      overflow: hidden;
      margin-top: 8px;
    }
    
    .color-slider-row:first-child {
      border-top: none;
    }
    
    .color-slider-row input[type="range"]::-webkit-slider-thumb {
      background: linear-gradient(135deg, #ff6b6b 0%, #4ecdc4 50%, #45b7d1 100%);
    }
    
    .color-slider-row input[type="range"]:hover::-webkit-slider-thumb {
      background: linear-gradient(135deg, #ff5252 0%, #26a69a 50%, #2196f3 100%);
      transform: scale(1.2);
    }

    .hidden { display: none !important; }
    
    /* Indicadores de estado para controles de color */
    .color-tab[data-color="red"] { border-left: 3px solid #ff6b6b; }
    .color-tab[data-color="orange"] { border-left: 3px solid #ff9f43; }
    .color-tab[data-color="yellow"] { border-left: 3px solid #feca57; }
    .color-tab[data-color="green"] { border-left: 3px solid #48ca5c; }
    .color-tab[data-color="aqua"] { border-left: 3px solid #0abde3; }
    .color-tab[data-color="blue"] { border-left: 3px solid #3742fa; }
    .color-tab[data-color="purple"] { border-left: 3px solid #a55eea; }
    .color-tab[data-color="magenta"] { border-left: 3px solid #fd79a8; }
    .color-tab[data-color="all"] { border-left: 3px solid var(--accent-blue); }
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .grid-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; }
    .flex-row { display: flex; gap: 8px; align-items: center; }
    .flex-col { display: flex; flex-direction: column; gap: 6px; }
    .text-center { text-align: center; }
    .text-mono { font-family: var(--font-mono); }
    .opacity-70 { opacity: 0.7; }
    .opacity-50 { opacity: 0.5; }
    
    /* Pantalla completa profesional */
    .fullscreen-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: var(--bg-primary);
      z-index: 9999;
      display: none;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(10px);
    }
    .fullscreen-overlay.show {
      display: flex;
      animation: fadeIn 0.3s ease;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    .fullscreen-canvas {
      max-width: 95%;
      max-height: 95%;
      object-fit: contain;
      border-radius: var(--radius-md);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
      border: 1px solid var(--border-secondary);
    }
    .fullscreen-info {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      color: var(--text-secondary);
      font-size: 12px;
      background: var(--bg-panel);
      padding: 8px 16px;
      border-radius: var(--radius-md);
      border: 1px solid var(--border-primary);
      backdrop-filter: blur(8px);
      font-family: var(--font-mono);
    }

    /* === NUEVAS FUNCIONALIDADES PROFESIONALES === */
    
    /* Histograma profesional */
    .histogram-container {
      background: #1a1a1a;
      border-radius: 8px;
      padding: 15px;
      margin: 10px 0;
      border: 1px solid #333;
    }

    .histogram-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }

    .histogram-channel {
      padding: 4px 8px;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
    }

    .histogram-channel.active {
      background: #007acc;
      border-color: #007acc;
    }

    /* Atajos de teclado */
    .shortcut-feedback {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 10px 15px;
      border-radius: 6px;
      font-size: 14px;
      z-index: 10000;
      opacity: 0;
      transform: translateX(100%);
      transition: all 0.3s ease;
    }

    .shortcut-feedback.show {
      opacity: 1;
      transform: translateX(0);
    }

    .shortcuts-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }

    .shortcuts-modal.show {
      opacity: 1;
      visibility: visible;
    }

    .shortcuts-content {
      background: #1a1a1a;
      border-radius: 12px;
      max-width: 800px;
      max-height: 80vh;
      overflow-y: auto;
      border: 1px solid #333;
    }

    .shortcuts-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px;
      border-bottom: 1px solid #333;
    }

    .shortcuts-header h3 {
      margin: 0;
      color: white;
    }

    .close-shortcuts {
      background: none;
      border: none;
      color: #999;
      font-size: 24px;
      cursor: pointer;
      padding: 0;
      width: 30px;
      height: 30px;
    }

    .shortcuts-body {
      padding: 20px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
    }

    .shortcut-section h4 {
      color: #007acc;
      margin: 0 0 10px 0;
      font-size: 16px;
    }

    .shortcut-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid #333;
    }

    .shortcut-key {
      font-family: 'Courier New', monospace;
      background: #333;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      color: #fff;
    }

    .shortcut-desc {
      color: #ccc;
      font-size: 14px;
    }



    /* Web Workers y performance */
    .worker-status {
      position: fixed;
      bottom: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.8);
      color: #00ff00;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 11px;
      font-family: monospace;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .worker-status.show {
      opacity: 1;
    }

    /* Mejoras de rendimiento */
    .processing-indicator {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 20px;
      border-radius: 8px;
      z-index: 10000;
      display: none;
    }

    .processing-indicator.show {
      display: block;
    }
  </style>
</head>

<body>
  <header class="page-header">
    <h1>Editor Vaca LoLa</h1>
    <div class="header-actions">
      <div class="workspace-info">
        <span class="text-mono opacity-70">Workspace: Professional</span>
      </div>
      <div class="btn-group">
        <button class="btn secondary btn-icon" title="Deshacer (Ctrl+Z)" id="undoBtn">‚Ü∂</button>
        <button class="btn secondary btn-icon" title="Rehacer (Ctrl+Y)" id="redoBtn">‚Ü∑</button>
        <button class="btn secondary btn-icon" title="Atajos de teclado (Ctrl+?)" onclick="window.showShortcuts()">‚å®Ô∏è</button>
        <button class="btn secondary btn-icon" title="Histograma (H)" onclick="document.getElementById('histogramPanel')?.classList.toggle('hidden')">üìä</button>
        <button class="btn secondary btn-icon" title="Configuraci√≥n">‚öôÔ∏è</button>
      </div>
    </div>
  </header>

  <div class="main-wrap">
    <!-- Panel de Controles Principales -->
    <div class="panel controls-panel">
      <div class="controls-panel-content">
        <div class="compact-section">
          <h3>Controles R√°pidos</h3>
          <div class="compact-section-content">
            <div class="btn-group">
              <button id="randomAll" class="btn secondary">Aleatorio</button>
              <button id="resetAll" class="btn secondary">Reiniciar</button>
            </div>
          </div>
        </div>
        
        <div class="compact-section">
          <h3>Ajustes Principales</h3>
          <div class="compact-section-content">
            <div id="slidersContainer" class="sliders-container"></div>
          </div>
        </div>
        
        <div class="compact-section">
          <h3>Control de Colores</h3>
          <div class="compact-section-content">
            <div class="color-selector">
              <div class="color-tabs">
                <button class="color-tab active" data-color="all">Todo</button>
                <button class="color-tab" data-color="red">Rojos</button>
                <button class="color-tab" data-color="orange">Naranjas</button>
                <button class="color-tab" data-color="yellow">Amarillos</button>
                <button class="color-tab" data-color="green">Verdes</button>
                <button class="color-tab" data-color="aqua">Aguamarinas</button>
                <button class="color-tab" data-color="blue">Azules</button>
                <button class="color-tab" data-color="purple">P√∫rpuras</button>
                <button class="color-tab" data-color="magenta">Magentas</button>
              </div>
              <div id="colorSlidersContainer" class="color-sliders-container">
                <div class="color-slider-row">
                  <label class="label">Matiz</label>
                  <input type="range" id="color-hue" min="-100" max="100" step="1" value="0">
                  <div class="value">0</div>
                  <button class="reset-btn" data-slider="hue">‚Ü∫</button>
                </div>
                <div class="color-slider-row">
                  <label class="label">Saturaci√≥n</label>
                  <input type="range" id="color-saturation" min="-100" max="100" step="1" value="0">
                  <div class="value">0</div>
                  <button class="reset-btn" data-slider="saturation">‚Ü∫</button>
                </div>
                <div class="color-slider-row">
                  <label class="label">Luminancia</label>
                  <input type="range" id="color-luminance" min="-100" max="100" step="1" value="0">
                  <div class="value">0</div>
                  <button class="reset-btn" data-slider="luminance">‚Ü∫</button>
                </div>
              </div>
              <div style="margin-top: 8px;">
                <button id="resetAllColors" class="btn secondary" style="width: 100%; padding: 6px; font-size: 11px;">üîÑ Reiniciar Colores</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Panel de Vista Previa Central -->
    <div class="panel preview-panel">
      <div class="section-header">
        <svg class="section-icon" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>
        <h2>Vista Previa</h2>
        <div class="btn-group" style="margin-left: auto;">
          <button id="beforeAfterBtn" class="btn secondary" title="Mant√©n presionado para ver original" style="padding: 6px 12px; font-size: 11px;">Antes/Despu√©s</button>
          <button id="randomImage" class="btn secondary btn-icon" title="Imagen Aleatoria">üé≤</button>
        </div>
      </div>
      <div class="preview-content">
        <div class="canvas-container">
          <canvas id="canvas" width="1200" height="800"></canvas>
          <canvas id="overlayHistogram" width="320" height="200" class="overlay-histogram" title="Histograma en tiempo real - Ctrl+F para pantalla completa"></canvas>
        </div>
        <div style="padding: 8px;">
          <div id="status" class="status-bar">Carga una imagen para comenzar</div>
          
          <div class="action-bar">
            <label class="btn secondary" style="border: 2px solid var(--border-accent) !important;">
              Subir Imagen
              <input id="fileInput" type="file" accept="image/*" class="hidden" />
            </label>
            <button id="downloadImg" class="btn" style="border: 2px solid #0080ff !important; background: linear-gradient(180deg, var(--accent-blue) 0%, #0052a3 100%) !important;">Descargar</button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Panel de Herramientas Secundarias -->
    <div class="panel tools-panel">
      <div class="tools-panel-content">
        <div class="compact-section">
          <h3>Configuraci√≥n Avanzada</h3>
          <div class="compact-section-content">
            

            
            <!-- Panel de Informaci√≥n de Imagen -->
            <div id="imageInfoPanel" class="image-info-container" style="background: #1a1a1a; border-radius: 8px; padding: 15px; margin: 10px 0; border: 1px solid #333;">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h4 style="margin: 0; color: var(--text-primary); font-size: 14px;">üìã Informaci√≥n de Imagen</h4>
                <button class="btn secondary" style="padding: 4px 8px; font-size: 11px;" onclick="updateImageInfo()">üîÑ</button>
              </div>
              <div class="info-grid" style="display: grid; grid-template-columns: 1fr; gap: 8px;">
                <div class="info-item" style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #333;">
                  <span class="info-label" style="color: #888; font-size: 12px;">Dimensiones:</span>
                  <span id="image-dimensions" style="color: #fff; font-size: 12px;">--</span>
                </div>
                <div class="info-item" style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #333;">
                  <span class="info-label" style="color: #888; font-size: 12px;">Formato:</span>
                  <span id="image-format" style="color: #fff; font-size: 12px;">--</span>
                </div>
                <div class="info-item" style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #333;">
                  <span class="info-label" style="color: #888; font-size: 12px;">Tama√±o:</span>
                  <span id="image-size" style="color: #fff; font-size: 12px;">--</span>
                </div>
                <div class="info-item" style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #333;">
                  <span class="info-label" style="color: #888; font-size: 12px;">Brillo promedio:</span>
                  <span id="avg-brightness" style="color: #fff; font-size: 12px;">--</span>
                </div>
                <div class="info-item" style="display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #333;">
                  <span class="info-label" style="color: #888; font-size: 12px;">Saturaci√≥n:</span>
                  <span id="avg-saturation" style="color: #fff; font-size: 12px;">--</span>
                </div>
                <div class="info-item" style="padding: 4px 0;">
                  <span class="info-label" style="color: #888; font-size: 12px; display: block; margin-bottom: 4px;">Colores dominantes:</span>
                  <div id="dominant-colors" class="color-palette" style="display: flex; gap: 4px;"></div>
                </div>
              </div>
            </div>
        
        <!-- Curvas Tonales Profesionales -->
        <div class="curves-section" style="margin-bottom: 20px;">
          <div class="curves-header" style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
            <label style="font-size: 13px; color: var(--text-secondary); font-weight: 600;">Curvas Tonales</label>
            <select id="curveChannel" style="padding: 4px 8px; font-size: 11px; background: var(--bg-tertiary); border: 1px solid var(--border-light); border-radius: var(--radius-sm); color: var(--text-secondary);">
              <option value="rgb">RGB</option>
              <option value="red">Rojo</option>
              <option value="green">Verde</option>
              <option value="blue">Azul</option>
              <option value="luminance">Luminancia</option>
            </select>
          </div>
          <div class="curves-container" style="position: relative; background: var(--bg-primary); border: 1px solid var(--border-light); border-radius: var(--radius-sm);">
            <canvas id="curvesCanvas" width="240" height="180" style="width: 100%; height: 140px; display: block; cursor: crosshair;"></canvas>
            <div class="curves-info" style="position: absolute; top: 4px; right: 6px; font-size: 10px; color: var(--text-muted); background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; pointer-events: none; opacity: 0; transition: opacity 0.2s;" id="curveInfo">Input: 0, Output: 0</div>
          </div>
          <div class="curves-controls" style="display: flex; gap: 4px; margin-top: 8px;">
            <button id="resetCurves" class="btn secondary" style="flex: 1; padding: 6px; font-size: 11px; border: 2px solid var(--border-accent) !important;">Lineal</button>
            <button id="autoContrast" class="btn secondary" style="flex: 1; padding: 6px; font-size: 11px; border: 2px solid var(--border-accent) !important;">Contraste</button>
            <button id="curveMediumContrast" class="btn secondary" style="flex: 1; padding: 6px; font-size: 11px; border: 2px solid var(--border-accent) !important;">Suave</button>
          </div>
          <div style="margin-top: 6px;">
            <button id="resetAllCurves" class="btn danger" style="width: 100%; padding: 6px; font-size: 11px; border: 2px solid #ff3333 !important;">üîÑ Reiniciar Todas las Curvas</button>
          </div>
          <div class="curves-presets" style="display: flex; gap: 2px; margin-top: 6px;">
            <button class="curve-preset-btn" data-preset="linear" style="flex: 1; padding: 3px; font-size: 10px; background: var(--bg-tertiary); border: 1px solid var(--border-light); border-radius: 2px; color: var(--text-muted); cursor: pointer;">Lineal</button>
            <button class="curve-preset-btn" data-preset="slight-s" style="flex: 1; padding: 3px; font-size: 10px; background: var(--bg-tertiary); border: 1px solid var(--border-light); border-radius: 2px; color: var(--text-muted); cursor: pointer;">S Suave</button>
            <button class="curve-preset-btn" data-preset="strong-s" style="flex: 1; padding: 3px; font-size: 10px; background: var(--bg-tertiary); border: 1px solid var(--border-light); border-radius: 2px; color: var(--text-muted); cursor: pointer;">S Fuerte</button>
            <button class="curve-preset-btn" data-preset="film" style="flex: 1; padding: 3px; font-size: 10px; background: var(--bg-tertiary); border: 1px solid var(--border-light); border-radius: 2px; color: var(--text-muted); cursor: pointer;">Pel√≠cula</button>
          </div>
        </div>

        <!-- Controles de Color -->
        <div style="margin-bottom: 16px;">
          <label style="font-size: 12px; color: var(--text-muted);">Balance de Color</label>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-top: 6px;">
            <div>
              <label style="font-size: 10px; color: var(--text-muted);">Sombras</label>
              <input id="shadowTint" type="range" min="-50" max="50" value="0" style="width: 100%;">
              <div id="shadowTintValue" style="font-size: 9px; color: var(--text-primary); text-align: center; margin-top: 2px;">0</div>
            </div>
            <div>
              <label style="font-size: 10px; color: var(--text-muted);">Luces</label>
              <input id="highlightTint" type="range" min="-50" max="50" value="0" style="width: 100%;">
              <div id="highlightTintValue" style="font-size: 9px; color: var(--text-primary); text-align: center; margin-top: 2px;">0</div>
            </div>
          </div>
        </div>

        <!-- Herramientas de Enfoque -->
        <div style="margin-bottom: 16px;">
          <label style="font-size: 12px; color: var(--text-muted);">Enfoque y Detalle</label>
          <div style="margin-top: 6px;">
            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
              <label style="font-size: 10px; color: var(--text-muted); width: 60px;">Cantidad</label>
              <input id="sharpenAmount" type="range" min="0" max="150" value="25" style="flex: 1;">
              <span id="sharpenAmountValue" style="font-size: 10px; color: var(--text-primary); width: 30px; text-align: center;">25</span>
            </div>
            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
              <label style="font-size: 10px; color: var(--text-muted); width: 60px;">Radio</label>
              <input id="sharpenRadius" type="range" min="0.5" max="3" step="0.1" value="1" style="flex: 1;">
              <span id="sharpenRadiusValue" style="font-size: 10px; color: var(--text-primary); width: 30px; text-align: center;">1.0</span>
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
              <label style="font-size: 10px; color: var(--text-muted); width: 60px;">Ruido</label>
              <input id="noiseReduction" type="range" min="0" max="100" value="0" style="flex: 1;">
              <span id="noiseReductionValue" style="font-size: 10px; color: var(--text-primary); width: 30px; text-align: center;">0</span>
            </div>
          </div>
        </div>

        <!-- Efectos Creativos -->
        <div style="margin-bottom: 16px;">
          <label style="font-size: 12px; color: var(--text-muted);">Efectos</label>
          <div style="margin-top: 6px;">
            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
              <label style="font-size: 10px; color: var(--text-muted); width: 60px;">Grano</label>
              <input id="filmGrain" type="range" min="0" max="100" value="0" style="flex: 1;">
              <span id="filmGrainValue" style="font-size: 10px; color: var(--text-primary); width: 30px; text-align: center;">0</span>
            </div>
            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
              <label style="font-size: 10px; color: var(--text-muted); width: 60px;">Desat.</label>
              <input id="partialDesaturation" type="range" min="0" max="100" value="0" style="flex: 1;">
              <span id="partialDesaturationValue" style="font-size: 10px; color: var(--text-primary); width: 30px; text-align: center;">0</span>
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
              <label style="font-size: 10px; color: var(--text-muted); width: 60px;">Orton</label>
              <input id="ortonEffect" type="range" min="0" max="100" value="0" style="flex: 1;">
              <span id="ortonEffectValue" style="font-size: 10px; color: var(--text-primary); width: 30px; text-align: center;">0</span>
            </div>
          </div>
        </div>

        <!-- Configuraci√≥n de Curvas -->
        <div>
          <label style="font-size: 12px; color: var(--text-muted);">Configuraci√≥n</label>
          <select id="curveMode" style="width: 100%; margin: 6px 0; padding: 6px; font-size: 13px;">
            <option value="0.5">Sutil</option>
            <option value="1" selected>Est√°ndar</option>
            <option value="1.8">Agresivo</option>
          </select>
          <input id="clarityIntensity" type="range" min="0.2" max="3" step="0.1" value="1" style="width: 100%;">
        </div>
        
        <!-- Histograma -->
        <div style="margin-top: 20px;">
          <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
            <label style="font-size: 12px; color: var(--text-muted); font-weight: 600;">Histograma RGB</label>
            <div style="display: flex; gap: 4px; font-size: 10px;">
              <span style="color: #ef4444;">‚óè</span><span style="color: var(--text-muted);">R</span>
              <span style="color: #10b981;">‚óè</span><span style="color: var(--text-muted);">G</span>
              <span style="color: #3b82f6;">‚óè</span><span style="color: var(--text-muted);">B</span>
            </div>
          </div>
          <div style="position: relative; background: var(--bg-primary); border: 1px solid var(--border-light); border-radius: var(--radius-sm); cursor: pointer;" title="Histograma de distribuci√≥n tonal">
            <canvas id="histogramCanvas" width="280" height="140" style="width: 100%; height: 100px; display: block;"></canvas>
          </div>
        </div>
          </div>
        </div>
        
        <div class="compact-section">
          <h3>Cargar Imagen</h3>
          <div class="compact-section-content">
            <div class="flex-row">
              <input id="imageUrl" type="text" placeholder="URL de imagen" style="flex: 1;" />
              <button id="loadUrl" class="btn">Cargar</button>
            </div>
          </div>
        </div>
        
        <div class="compact-section">
          <h3>Guardar Preset</h3>
          <div class="compact-section-content">
            <input id="presetName" type="text" placeholder="Nombre del preset" style="margin-bottom: 8px;" />
            <div class="flex-row">
              <button id="savePreset" class="btn" style="flex: 1;">Guardar</button>
              <select id="xmpMode" style="flex: 1;">
                <option value="modern">XMP</option>
                <option value="legacy">Legado</option>
              </select>
            </div>
            <button id="downloadXmp" class="btn secondary" style="width: 100%; margin-top: 8px;">Descargar XMP</button>
          </div>
        </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Indicadores profesionales -->
  <div id="processingIndicator" class="processing-indicator">
    <div>Procesando imagen...</div>
    <div style="margin-top: 10px; font-size: 12px; opacity: 0.7;">Usando Web Workers para mejor rendimiento</div>
  </div>
  
  <div id="workerStatus" class="worker-status">Workers: Ready</div>
  
  <!-- Zoom Controls en Canvas -->
  <div class="zoom-controls" style="display: none;">
    <button class="zoom-btn" onclick="window.zoomManager?.zoomOut()" title="Alejar (Ctrl+-)">‚àí</button>
    <button class="zoom-btn" onclick="window.zoomManager?.fitToScreen()" title="Ajustar (Ctrl+0)">‚åÇ</button>
    <button class="zoom-btn" onclick="window.zoomManager?.actualSize()" title="100% (Ctrl+1)">1:1</button>
    <button class="zoom-btn" onclick="window.zoomManager?.zoomIn()" title="Acercar (Ctrl++)">+</button>
  </div>

  <!-- Asistente IA -->
  <button id="aiToggleBtn" class="ai-toggle-btn" title="Cow AI">
    <span style="font-size: 24px;">üêÑ</span>
  </button>
  
  <!-- Modal del Asistente IA -->
  <div id="chatModal" class="chat-modal">
    <div class="chat-header">
      <h3>Cow AI</h3>
      <div style="display: flex; gap: 8px; align-items: center;">
        <button id="chatStats" class="chat-close" title="Ver estad√≠sticas" style="font-size: 14px;">üìà</button>
        <button id="chatClose" class="chat-close">√ó</button>
      </div>
    </div>
    <div id="chatContainer">
      <div id="chatMessages"></div>
      <div id="chatInputArea">
        <input type="text" id="chatInput" placeholder="Describe el estilo que buscas..." />
        <button id="chatSendBtn" class="btn">Enviar</button>
      </div>
    </div>
  </div>

  <script>
    // SECURITY: No hardcoded credentials - API keys retrieved securely
    // Secure API key configuration
    const getUserApiKey = () => {
      // Check environment variable first
      if (typeof process !== 'undefined' && process.env?.GEMINI_API_KEY) {
        return process.env.GEMINI_API_KEY;
      }
      
      // Check localStorage for user-provided key
      const stored = localStorage.getItem('user_gemini_key');
      if (stored) return stored;
      
      // Prompt user for API key if none found
      const key = prompt('Para usar el asistente IA, ingresa tu API key de Google Gemini:\n\nObten una gratis en: https://makersuite.google.com/app/apikey');
      if (key) {
        localStorage.setItem('user_gemini_key', key);
        return key;
      }
      
      throw new Error('API Key requerida para usar el asistente de IA');
    };
    
    // Inicializar el chatbot mejorado cuando el DOM est√© listo
    let chatbotInitialized = false;
    document.addEventListener('DOMContentLoaded', () => {
      if (!chatbotInitialized && window.ImageEditorChatbot && document.getElementById('chatMessages')) {
        window.chatbot = new window.ImageEditorChatbot();
        chatbotInitialized = true;
        console.log('Chatbot mejorado inicializado');
      }
    });
    
    // Allow users to set their own key if desired
    window.setCustomApiKey = () => {
      const key = prompt('Ingresa tu propia API key (opcional):');
      if (key) {
        localStorage.setItem('user_gemini_key', key);
        alert('API key personalizada guardada');
      }
    };
    
    // === INICIALIZACI√ìN DE SISTEMAS PROFESIONALES ===
    let imageWorker = null;
    let histogramRenderer = null;
    let zoomManager = null;
    
    // Inicializar Web Worker con fallback
    const initImageWorker = () => {
      try {
        imageWorker = new Worker('workers/imageWorker.js');
        imageWorker.onmessage = (e) => {
          const { type, data } = e.data;
          if (type === 'processed') {
            const canvas = document.getElementById('canvas');
            if (canvas) {
              const ctx = canvas.getContext('2d');
              ctx.putImageData(data.imageData, 0, 0);
            }
            hideProcessingIndicator();
          }
        };
        updateWorkerStatus('Workers: Active');
      } catch (error) {
        imageWorker = null;
        updateWorkerStatus('Workers: Fallback');
      }
    };
    // Histograma b√°sico
    const updateHistogram = () => {
      const canvas = document.getElementById('histogramCanvas');
      if (!canvas || !dom?.ctx) return;
      
      const ctx = canvas.getContext('2d');
      const imageData = dom.ctx.getImageData(0, 0, dom.canvas.width, dom.canvas.height);
      const data = imageData.data;
      
      const histogram = { r: new Array(256).fill(0), g: new Array(256).fill(0), b: new Array(256).fill(0) };
      
      for (let i = 0; i < data.length; i += 4) {
        histogram.r[data[i]]++;
        histogram.g[data[i + 1]]++;
        histogram.b[data[i + 2]]++;
      }
      
      const maxVal = Math.max(...histogram.r, ...histogram.g, ...histogram.b);
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.globalCompositeOperation = 'screen';
      
      ['r', 'g', 'b'].forEach((channel, idx) => {
        ctx.strokeStyle = ['#ff4444', '#44ff44', '#4444ff'][idx];
        ctx.beginPath();
        for (let i = 0; i < 256; i++) {
          const x = (i / 255) * canvas.width;
          const y = canvas.height - (histogram[channel][i] / maxVal) * canvas.height;
          i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        }
        ctx.stroke();
      });
    };
    
    // Zoom Manager - Actualizado para usar el nuevo sistema
    const initZoomManager = () => {
      // El nuevo sistema de zoom se inicializa en initZoomSystem
      // Mantener compatibilidad con c√≥digo existente
      window.zoomManager = {
        currentZoom: () => window.zoomSystem ? window.zoomSystem.currentZoom() : 1,
        fitToScreen: () => window.zoomSystem ? window.zoomSystem.fitToScreen() : null,
        actualSize: () => window.zoomSystem ? window.zoomSystem.actualSize() : null,
        zoomIn: () => window.zoomSystem ? window.zoomSystem.zoomIn() : null,
        zoomOut: () => window.zoomSystem ? window.zoomSystem.zoomOut() : null,
        setZoom: (zoom) => window.zoomSystem ? window.zoomSystem.setZoom(zoom) : null
      };
    };
    
    // Indicadores de estado
    const showProcessingIndicator = () => {
      document.getElementById('processingIndicator')?.classList.add('show');
    };
    
    const hideProcessingIndicator = () => {
      document.getElementById('processingIndicator')?.classList.remove('show');
    };
    
    const updateWorkerStatus = (status) => {
      const statusEl = document.getElementById('workerStatus');
      if (statusEl) {
        statusEl.textContent = status;
        statusEl.classList.add('show');
        setTimeout(() => statusEl.classList.remove('show'), 3000);
      }
    };
    
    // Inicializar sistemas
    document.addEventListener('DOMContentLoaded', () => {
      initImageWorker();
      initZoomManager();
      
      // Configurar histograma
      window.updateHistogram = updateHistogram;
      
      // Configurar controles de histograma
      document.querySelectorAll('.histogram-channel').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.histogram-channel').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
        });
      });
    });
    
    // Variables globales necesarias
    let dom = { canvas: null, ctx: null };
    let currentImage = null;
    let presets = JSON.parse(localStorage.getItem('imagePresets') || '[]');
    
    // Configuraci√≥n de controles
    const controls = {
      exposure: 0, contrast: 0, highlights: 0, shadows: 0, whites: 0, blacks: 0,
      temperature: 0, tint: 0, vibrance: 0, saturation: 0, hue: 0,
      clarity: 0, dehaze: 0, vignette: 0, sharpness: 0
    };
    
    // Configurar canvas y zoom controls
    setTimeout(() => {
      const canvas = document.getElementById('canvas');
      if (canvas) {
        canvas.addEventListener('mouseenter', () => {
          const zoomControls = document.querySelector('.zoom-controls');
          if (zoomControls) zoomControls.style.display = 'flex';
        });
        canvas.addEventListener('mouseleave', () => {
          const zoomControls = document.querySelector('.zoom-controls');
          if (zoomControls) zoomControls.style.display = 'none';
        });
      }
    }, 100);
    
    const chatMessages = document.getElementById('chatMessages');
    const chatInput = document.getElementById('chatInput');
    const chatSendBtn = document.getElementById('chatSendBtn');
    
    function addMessage(content, isUser = false) {
      const messageDiv = document.createElement('div');
      messageDiv.className = `chat-message ${isUser ? 'user-message' : 'bot-message'}`;
      messageDiv.textContent = content;
      chatMessages.appendChild(messageDiv);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }
    
    function showTypingIndicator() {
      const typingDiv = document.createElement('div');
      typingDiv.className = 'typing-indicator';
      typingDiv.innerHTML = '<span></span><span></span><span></span>';
      typingDiv.id = 'typing';
      chatMessages.appendChild(typingDiv);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }
    
    function hideTypingIndicator() {
      const typing = document.getElementById('typing');
      if (typing) typing.remove();
    }
    
    async function sendToGemini(message) {
      try {
        const apiKey = getUserApiKey();
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            contents: [{
              parts: [{
                text: `Eres un asistente experto en edici√≥n de im√°genes. Ayuda con t√©cnicas, herramientas y consejos de edici√≥n fotogr√°fica. Usuario: ${message}`
              }]
            }]
          })
        });
        
        if (!response.ok) {
          const errorData = await response.json();
          console.error('Error API:', response.status, errorData);
          return `Error ${response.status}: ${errorData.error?.message || 'Error desconocido'}`;
        }
        
        const data = await response.json();
        return data.candidates[0].content.parts[0].text;
      } catch (error) {
        console.error('Error:', error);
        return `Error: ${error.message}`;
      }
    }
    
    // Respuestas simples para conversaci√≥n b√°sica
    function getSimpleResponse(message) {
      const msg = message.toLowerCase();
      const responses = {
        'hola': '¬°Hola! üëã ¬øEn qu√© puedo ayudarte con la edici√≥n de tu imagen?',
        'hi': '¬°Hi! üëã How can I help you with image editing?',
        'hello': '¬°Hello! üëã What editing style are you looking for?',
        'buenos d√≠as': '¬°Buenos d√≠as! ‚òÄÔ∏è ¬øQu√© tipo de edici√≥n quieres hacer hoy?',
        'buenas tardes': '¬°Buenas tardes! üåÖ ¬øC√≥mo puedo ayudarte con tu imagen?',
        'buenas noches': '¬°Buenas noches! üåô ¬øQu√© estilo buscas para tu foto?',
        'gracias': '¬°De nada! üòä ¬øHay algo m√°s en lo que pueda ayudarte?',
        'thanks': 'You\'re welcome! üòä Anything else I can help with?',
        'adi√≥s': '¬°Hasta luego! üëã Que tengas un buen d√≠a editando im√°genes.',
        'bye': 'Goodbye! üëã Happy editing!',
        'ayuda': '¬°Por supuesto! Puedes pedirme estilos como: "tono c√°lido", "vintage", "dram√°tico", "suave", etc. üé®',
        'help': 'Sure! You can ask for styles like: "warm tone", "vintage", "dramatic", "soft", etc. üé®',
        '¬øqu√© puedes hacer?': 'Puedo ajustar los controles de edici√≥n seg√∫n el estilo que me describas. Prueba con: "m√°s contraste", "tono fr√≠o", "vintage", etc. ‚ú®',
        'what can you do': 'I can adjust editing controls based on the style you describe. Try: "more contrast", "cool tone", "vintage", etc. ‚ú®'
      };
      
      for (const [key, response] of Object.entries(responses)) {
        if (msg.includes(key)) return response;
      }
      return null;
    }

    // Funciones del sistema antiguo comentadas - usa el chatbot mejorado
    /*
    async function handleSendMessage() {
      // Esta funci√≥n ahora es manejada por ImageEditorChatbot
    }
    */
    
    // Los event listeners se configuran en el chatbot mejorado
    
    // No agregar mensaje de bienvenida aqu√≠ - lo maneja el chatbot mejorado
  </script>

</body>
</html>


  <script>
  document.addEventListener('DOMContentLoaded', () => {
    // --- Definiciones y Constantes ---
    const SLIDERS_CONFIG = [
      {id:'exposure', label:'Exposici√≥n', min:-100, max:100, step:1, def:0},{id:'contrast', label:'Contraste', min:-100, max:100, step:1, def:0},{id:'saturation', label:'Saturaci√≥n', min:-100, max:100, step:1, def:0},{id:'highlights', label:'Luces', min:-100, max:100, step:1, def:0},{id:'shadows', label:'Sombras', min:-100, max:100, step:1, def:0},{id:'whites', label:'Blancos', min:-100, max:100, step:1, def:0},{id:'blacks', label:'Negros', min:-100, max:100, step:1, def:0},{id:'clarity', label:'Claridad', min:-100, max:100, step:1, def:0},{id:'vibrance', label:'Vibrance', min:-100, max:100, step:1, def:0},{id:'sharpness', label:'Nitidez', min:-100, max:100, step:1, def:0},{id:'temperature', label:'Temperatura', min:-100, max:100, step:1, def:0},{id:'tint', label:'Tinte', min:-100, max:100, step:1, def:0},{id:'vignette', label:'Vi√±eta', min:-100, max:100, step:1, def:0}
    ];
    const PRESET_KEY = 'lr_presets_v4';
    const DEFAULT_IMAGE_SRC = `data:image/svg+xml;utf8,${encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' width='1200' height='800'><rect width='100%' height='100%' fill='#334155'/><text x='50%' y='50%' fill-opacity='0.8' text-anchor='middle' font-family='Inter, sans-serif' font-size='48' fill='#94a3b8'>Carga una imagen para comenzar</text></svg>`)}`;

    // --- Estado de la Aplicaci√≥n ---
    const appState = { sliderValues: {}, ui: { sliders: {}, displays: {} }, image: { instance: new Image(), gallery: [DEFAULT_IMAGE_SRC], currentIndex: 0 }, drawPending: false, showingOriginal: false, colorValues: {} };
    appState.image.instance.crossOrigin = 'anonymous';
    
    // Sistema de control de colores
    let colorSystem = null;

    // --- Selectores de DOM (Cacheados) ---
    const dom = {};
    const getDomElements = () => {
        const ids = ['slidersContainer', 'colorSlidersContainer', 'curveMode', 'clarityIntensity', 'canvas', 'status', 'presetName', 'xmpMode', 'randomAll', 'resetAll', 'savePreset', 'downloadXmp', 'imageUrl', 'loadUrl', 'fileInput', 'randomImage', 'downloadImg', 'chatMessages', 'chatInput', 'chatSendBtn', 'curvesCanvas', 'resetCurves', 'autoContrast', 'curveMediumContrast', 'resetAllCurves', 'shadowTint', 'highlightTint', 'sharpenAmount', 'sharpenRadius', 'noiseReduction', 'filmGrain', 'partialDesaturation', 'ortonEffect', 'aiToggleBtn', 'chatModal', 'chatClose', 'beforeAfterBtn', 'histogramCanvas', 'overlayHistogram'];
        ids.forEach(id => dom[id] = document.getElementById(id));
        dom.ctx = dom.canvas.getContext('2d', { willReadFrequently: false });
    };

    // --- Funciones de Utilidad ---
    const log = (...args) => { if(dom.log) dom.log.textContent = `${(new Date()).toLocaleTimeString()} ‚Äî ${args.join(' ')}\n${dom.log.textContent}`; };
    const clamp = (v) => v < 0 ? 0 : (v > 255 ? 255 : Math.round(v));
    const smoothstep = (a, b, x) => { x = Math.max(0, Math.min(1, (x - a) / (b - a))); return x * x * (3 - 2 * x); };
    const str2utf8uint8 = (s) => new TextEncoder().encode(s);
    const escapeXml = (s) => String(s).replace(/[<>&'"]/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','"':'&quot;',"'":'&apos;'}[c]));

    // --- L√≥gica de Renderizado ---
    const drawPlaceholder = (msg) => { dom.ctx.save(); dom.ctx.fillStyle = '#334155'; dom.ctx.fillRect(0,0,dom.canvas.width,dom.canvas.height); dom.ctx.fillStyle = '#94a3b8'; dom.ctx.font = "24px 'Inter'"; dom.ctx.textAlign='center'; dom.ctx.fillText(msg||'Cargando...',dom.canvas.width/2,dom.canvas.height/2); dom.ctx.restore(); };
    
    // --- Funciones de Histograma ---
    const calculateHistogram = (imageData) => {
        const data = imageData.data;
        const histR = new Array(256).fill(0);
        const histG = new Array(256).fill(0);
        const histB = new Array(256).fill(0);
        
        for(let i = 0; i < data.length; i += 4) {
            histR[data[i]]++;
            histG[data[i + 1]]++;
            histB[data[i + 2]]++;
        }
        
        return { r: histR, g: histG, b: histB };
    };
    
    const drawHistogram = (canvas, histogram) => {
        const ctx = canvas.getContext('2d');
        const w = canvas.width, h = canvas.height;
        
        ctx.clearRect(0, 0, w, h);
        
        // Fondo con gradiente profesional
        const bgGrad = ctx.createLinearGradient(0, 0, 0, h);
        bgGrad.addColorStop(0, '#0f172a');
        bgGrad.addColorStop(1, '#1e293b');
        ctx.fillStyle = bgGrad;
        ctx.fillRect(0, 0, w, h);
        
        // Grid profesional
        ctx.strokeStyle = '#334155';
        ctx.lineWidth = 0.5;
        for(let i = 1; i < 4; i++) {
            const x = (w / 4) * i;
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
            const y = (h / 4) * i;
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
        }
        
        const maxR = Math.max(...histogram.r);
        const maxG = Math.max(...histogram.g);
        const maxB = Math.max(...histogram.b);
        const maxVal = Math.max(maxR, maxG, maxB);
        
        if(maxVal === 0) return;
        
        // Dibujar curvas suaves en lugar de barras
        const drawChannel = (data, color, alpha = 0.8) => {
            ctx.strokeStyle = color;
            ctx.fillStyle = color.replace('1)', alpha + ')');
            ctx.lineWidth = 1.5;
            
            ctx.beginPath();
            ctx.moveTo(0, h);
            
            for(let i = 0; i < 256; i++) {
                const x = (i / 255) * w;
                const y = h - (data[i] / maxVal) * h;
                if(i === 0) ctx.lineTo(x, y);
                else ctx.lineTo(x, y);
            }
            
            ctx.lineTo(w, h);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        };
        
        // Dibujar canales con modo de mezcla
        ctx.globalCompositeOperation = 'screen';
        drawChannel(histogram.r, 'rgba(239, 68, 68, 1)', 0.6);
        drawChannel(histogram.g, 'rgba(16, 185, 129, 1)', 0.6);
        drawChannel(histogram.b, 'rgba(59, 130, 246, 1)', 0.6);
        ctx.globalCompositeOperation = 'source-over';
        
        // Borde profesional
        ctx.strokeStyle = '#475569';
        ctx.lineWidth = 1;
        ctx.strokeRect(0, 0, w, h);
        
        // Indicadores de sombras, medios tonos y luces
        ctx.fillStyle = 'rgba(148, 163, 184, 0.3)';
        ctx.fillRect(0, h - 3, w * 0.33, 3);
        ctx.fillStyle = 'rgba(203, 213, 225, 0.3)';
        ctx.fillRect(w * 0.33, h - 3, w * 0.34, 3);
        ctx.fillStyle = 'rgba(241, 245, 249, 0.3)';
        ctx.fillRect(w * 0.67, h - 3, w * 0.33, 3);
    };
    // Cache ultra-optimizado para curvas
    const curveCache = {
        rgb: new Uint8Array(256),
        red: new Uint8Array(256),
        green: new Uint8Array(256),
        blue: new Uint8Array(256),
        luminance: new Uint8Array(256),
        dirty: { rgb: true, red: true, green: true, blue: true, luminance: true }
    };
    
    const buildCurveCache = (channel) => {
        const points = curveState.channels[channel];
        const cache = curveCache[channel];
        
        // Inicializar con valores lineales
        for(let i = 0; i < 256; i++) cache[i] = i;
        
        if(points.length <= 2) {
            curveCache.dirty[channel] = false;
            return;
        }
        
        // Ordenar puntos una sola vez
        const sorted = points.slice().sort((a, b) => a.x - b.x);
        
        // Interpolaci√≥n lineal optimizada
        for(let i = 0; i < 256; i++) {
            for(let j = 0; j < sorted.length - 1; j++) {
                const p1 = sorted[j], p2 = sorted[j + 1];
                if(i >= p1.x && i <= p2.x) {
                    const t = (i - p1.x) / (p2.x - p1.x);
                    cache[i] = Math.max(0, Math.min(255, p1.y + t * (p2.y - p1.y)));
                    break;
                }
            }
        }
        curveCache.dirty[channel] = false;
    };
    
    const applyCurve = (value, channel) => {
        if(curveCache.dirty[channel]) buildCurveCache(channel);
        return curveCache[channel][Math.max(0, Math.min(255, Math.round(value)))];
    };
    
    const drawPreview = () => {
        if (!appState.image.instance.complete || appState.image.instance.naturalWidth === 0) { drawPlaceholder('Imagen no disponible'); return; }
        
        // Configurar alta calidad de renderizado
        dom.ctx.imageSmoothingEnabled = true;
        dom.ctx.imageSmoothingQuality = 'high';
        
        // Si est√° mostrando la imagen original, solo dibujar sin efectos
        if (appState.showingOriginal) {
            const w = dom.canvas.width, h = dom.canvas.height;
            dom.ctx.clearRect(0, 0, w, h);
            dom.ctx.drawImage(appState.image.instance, 0, 0, w, h);
            dom.status.textContent = 'Mostrando imagen original';
            return;
        }
        const w = dom.canvas.width, h = dom.canvas.height; 
        const tmpCanvas = document.createElement('canvas'); 
        tmpCanvas.width=w; tmpCanvas.height=h; 
        const tctx=tmpCanvas.getContext('2d', { willReadFrequently: false }); // Optimizaci√≥n
        
        const exposure = Number(appState.sliderValues.exposure);
        const brightness = exposure >= 0 ? 1 + exposure * 0.02 : Math.max(0.1, 1 + exposure * 0.008);
        
        // Usar filtros CSS cuando sea posible (m√°s r√°pido)
        tctx.filter=`brightness(${brightness}) contrast(${100+Number(appState.sliderValues.contrast)}%) saturate(${100+Number(appState.sliderValues.saturation)}%)`;
        
        try{tctx.drawImage(appState.image.instance,0,0,w,h);}catch(e){log('Error al dibujar:',e);drawPlaceholder('Error de dibujado');return;}
        
        // Optimizaci√≥n: solo procesar si hay cambios reales
        const hasChanges = Object.values(appState.sliderValues).some(v => Number(v) !== 0) ||
            (dom.shadowTint && Number(dom.shadowTint.value) !== 0) ||
            (dom.highlightTint && Number(dom.highlightTint.value) !== 0) ||
            (dom.filmGrain && Number(dom.filmGrain.value) > 0) ||
            (dom.partialDesaturation && Number(dom.partialDesaturation.value) > 0) ||
            (dom.sharpenAmount && Number(dom.sharpenAmount.value) > 0) ||
            (dom.noiseReduction && Number(dom.noiseReduction.value) > 0) ||
            (dom.ortonEffect && Number(dom.ortonEffect.value) > 0) ||
            curveState.channels.rgb.length > 2 || curveState.channels.red.length > 2 ||
            curveState.channels.green.length > 2 || curveState.channels.blue.length > 2 ||
            curveState.channels.luminance.length > 2;
            
        if(hasChanges) {
            const imageData = tctx.getImageData(0,0,w,h);
            const data = imageData.data;
            
            // Pre-calcular valores para mejor rendimiento
            const temp = Number(appState.sliderValues.temperature) * 0.12;
            const tint = Number(appState.sliderValues.tint) * 0.08;
            const highlights = Number(appState.sliderValues.highlights);
            const shadows = Number(appState.sliderValues.shadows);
            const vibrance = Number(appState.sliderValues.vibrance);
            const clarity = Number(appState.sliderValues.clarity) * (parseFloat(dom.clarityIntensity?.value) || 1);
            const shadowTint = dom.shadowTint ? Number(dom.shadowTint.value) : 0;
            const highlightTint = dom.highlightTint ? Number(dom.highlightTint.value) : 0;
            const filmGrain = dom.filmGrain ? Number(dom.filmGrain.value) : 0;
            const partialDesat = dom.partialDesaturation ? Number(dom.partialDesaturation.value) : 0;
            const sharpenAmount = dom.sharpenAmount ? Number(dom.sharpenAmount.value) : 0;
            const noiseReduction = dom.noiseReduction ? Number(dom.noiseReduction.value) : 0;
            
            // Pre-verificar curvas activas
            const rgbActive = curveState.channels.rgb.length > 2;
            const redActive = curveState.channels.red.length > 2;
            const greenActive = curveState.channels.green.length > 2;
            const blueActive = curveState.channels.blue.length > 2;
            const luminanceActive = curveState.channels.luminance.length > 2;
            const needsCurves = rgbActive || redActive || greenActive || blueActive || luminanceActive;
            
            // Procesamiento ultra-optimizado
            const processChunk = (start, end) => {
                for(let i = start; i < end; i += 4) {
                    let r = data[i], g = data[i+1], b = data[i+2];
                    
                    // Curvas optimizadas
                    if(needsCurves) {
                        if(rgbActive) {
                            r = applyCurve(r, 'rgb'); g = applyCurve(g, 'rgb'); b = applyCurve(b, 'rgb');
                        }
                        if(redActive) r = applyCurve(r, 'red');
                        if(greenActive) g = applyCurve(g, 'green');
                        if(blueActive) b = applyCurve(b, 'blue');
                        
                        // Aplicar curva de luminancia
                        if(luminanceActive) {
                            const lum = 0.299*r + 0.587*g + 0.114*b;
                            const newLum = applyCurve(lum, 'luminance');
                            if(lum > 0) {
                                const factor = newLum / lum;
                                r *= factor; g *= factor; b *= factor;
                            }
                        }
                    }
                    
                    // Temperatura y tinte
                    if(temp !== 0 || tint !== 0) {
                        r += temp - tint * 0.25; g += tint; b += -temp + tint * 0.25;
                    }
                    
                    const lum = 0.299*r + 0.587*g + 0.114*b;
                    
                    // Balance tonal por zonas
                    if(shadowTint !== 0 && lum < 85) {
                        r += shadowTint * 0.3; g += shadowTint * 0.1; b -= shadowTint * 0.2;
                    } else if(highlightTint !== 0 && lum > 170) {
                        r += highlightTint * 0.2; g += highlightTint * 0.3; b += highlightTint * 0.1;
                    }
                    
                    // Highlights y shadows optimizados
                    if(highlights !== 0) {
                        const t = smoothstep(128, 255, lum);
                        const f = 1 + (highlights/100) * t;
                        r *= f; g *= f; b *= f;
                    }
                    if(shadows !== 0) {
                        const t = 1 - smoothstep(0, 153, lum);
                        const f = 1 + (shadows/100) * t;
                        r *= f; g *= f; b *= f;
                    }
                    
                    // Whites y Blacks
                    const whites = Number(appState.sliderValues.whites);
                    const blacks = Number(appState.sliderValues.blacks);
                    if(whites !== 0) {
                        const t = smoothstep(200, 255, lum);
                        const f = 1 + (whites/100) * t;
                        r *= f; g *= f; b *= f;
                    }
                    if(blacks !== 0) {
                        const t = 1 - smoothstep(0, 55, lum);
                        const f = 1 + (blacks/100) * t;
                        r *= f; g *= f; b *= f;
                    }
                    
                    // Vibrance optimizado
                    if(vibrance !== 0) {
                        const max = Math.max(r, g, b);
                        const avg = (r + g + b) / 3;
                        const s = max > 0 ? (max - avg) / max : 0;
                        const extra = (vibrance/100) * (1 - s);
                        r = avg + (r - avg) * (1 + extra);
                        g = avg + (g - avg) * (1 + extra);
                        b = avg + (b - avg) * (1 + extra);
                    }
                    
                    // Sharpness se aplica despu√©s del procesamiento principal
                    
                    // Tint adicional (balance magenta/verde) - ya procesado arriba
                    // const tint = Number(appState.sliderValues.tint);
                    // if(tint !== 0) {
                    //     const tintFactor = tint * 0.5;
                    //     r += tintFactor; b += tintFactor; g -= tintFactor;
                    // }
                    
                    // Clarity
                    if(clarity !== 0) {
                        const factor = 1 + clarity/600;
                        r *= factor; g *= factor; b *= factor;
                    }
                    
                    // Desaturaci√≥n parcial
                    if(partialDesat > 0) {
                        const gray = 0.299*r + 0.587*g + 0.114*b;
                        const factor = 1 - (partialDesat/100);
                        r = gray + (r - gray) * factor;
                        g = gray + (g - gray) * factor;
                        b = gray + (b - gray) * factor;
                    }
                    
                    // Grano de pel√≠cula
                    if(filmGrain > 0 && i % 16 === 0) {
                        const noise = (Math.random() - 0.5) * filmGrain * 0.8;
                        r += noise; g += noise; b += noise;
                    }
                    
                    // Reducci√≥n de ruido (suavizado)
                    if(noiseReduction > 0 && i % 20 === 0) {
                        const factor = 1 - (noiseReduction / 200);
                        const avgNeighbor = (data[i-4] + data[i+4]) / 2;
                        r = r * factor + avgNeighbor * (1 - factor);
                        g = g * factor + avgNeighbor * (1 - factor);
                        b = b * factor + avgNeighbor * (1 - factor);
                    }
                    
                    // Control de colores HSL se aplica en ambos paths
                    
                    data[i] = clamp(r); data[i+1] = clamp(g); data[i+2] = clamp(b);
                }
            };
            
            // Procesamiento directo sin chunks para curvas
            if(needsCurves && !temp && !tint && !highlights && !shadows && !vibrance && !clarity && !shadowTint && !highlightTint && !partialDesat && !filmGrain) {
                // Solo curvas - procesamiento ultra-r√°pido
                for(let i = 0; i < data.length; i += 4) {
                    let r = data[i], g = data[i+1], b = data[i+2];
                    
                    if(rgbActive) {
                        r = applyCurve(r, 'rgb'); g = applyCurve(g, 'rgb'); b = applyCurve(b, 'rgb');
                    }
                    if(redActive) r = applyCurve(r, 'red');
                    if(greenActive) g = applyCurve(g, 'green');
                    if(blueActive) b = applyCurve(b, 'blue');
                    
                    // Aplicar curva de luminancia
                    if(luminanceActive) {
                        const lum = 0.299*r + 0.587*g + 0.114*b;
                        const newLum = applyCurve(lum, 'luminance');
                        if(lum > 0) {
                            const factor = newLum / lum;
                            r *= factor; g *= factor; b *= factor;
                        }
                    }
                    
                    // Sistema profesional de control de colores HSL
                    if(colorSystem && colorSystem.hasActiveChanges()) {
                        const [newR, newG, newB] = colorSystem.processPixel(r, g, b);
                        r = newR; g = newG; b = newB;
                    }
                    
                    data[i] = r; data[i+1] = g; data[i+2] = b;
                }
            } else {
                // Procesamiento por lotes optimizado con control de colores
                const batchSize = Math.min(data.length, 65536);
                for(let start = 0; start < data.length; start += batchSize) {
                    processChunk(start, Math.min(start + batchSize, data.length));
                }
                
                // Aplicar control de colores HSL ultra-optimizado
                if(colorSystem && colorSystem.hasActiveChanges()) {
                    // Procesar cada 2do p√≠xel para mejor rendimiento durante arrastre
                    const step = 8; // Saltar p√≠xeles para mayor velocidad
                    for(let i = 0; i < data.length; i += step) {
                        const [newR, newG, newB] = colorSystem.processPixel(data[i], data[i+1], data[i+2]);
                        data[i] = newR; data[i+1] = newG; data[i+2] = newB;
                        // Aplicar el mismo cambio al p√≠xel siguiente para suavizar
                        if(i + 4 < data.length) {
                            data[i+4] = newR; data[i+5] = newG; data[i+6] = newB;
                        }
                    }
                }
            }
            
            tctx.putImageData(imageData, 0, 0);
        }
        
        // Aplicar nitidez estilo Lightroom
        const sharpness = Number(appState.sliderValues.sharpness);
        const sharpenAmount = dom.sharpenAmount ? Number(dom.sharpenAmount.value) : 0;
        
        if(sharpness !== 0 || sharpenAmount > 0) {
            const totalSharp = sharpness + sharpenAmount;
            if(totalSharp > 0) {
                const sharpFactor = 1 + totalSharp / 150;
                tctx.filter = `contrast(${100 + totalSharp/3}%) brightness(${100 + totalSharp/10}%)`;
                tctx.drawImage(tmpCanvas, 0, 0);
                tctx.filter = 'none';
            }
        }
        
        // Efectos que usan filtros (m√°s r√°pidos)
        const vignette = Number(appState.sliderValues.vignette);
        const ortonEffect = dom.ortonEffect ? Number(dom.ortonEffect.value) : 0;
        
        // Orton Effect optimizado
        if(ortonEffect > 0) {
            tctx.save();
            tctx.globalCompositeOperation = 'overlay';
            tctx.globalAlpha = ortonEffect / 200;
            tctx.filter = `blur(${Math.max(5, ortonEffect/10)}px) contrast(${120 + ortonEffect/2}%) brightness(${105 + ortonEffect/4}%)`;
            tctx.drawImage(tmpCanvas, 0, 0);
            tctx.restore();
        }
        
        // Vi√±eta
        if(vignette!==0){const grad=tctx.createRadialGradient(w/2,h/2,Math.min(w,h)*0.15,w/2,h/2,Math.max(w,h)),vAmt=Math.abs(vignette)/100;if(vignette<0){grad.addColorStop(0,'#0000');grad.addColorStop(1,`rgba(0,0,0,${vAmt})`)}else{grad.addColorStop(0,'#fff0');grad.addColorStop(1,`rgba(255,255,255,${vAmt*0.6})`)} tctx.fillStyle=grad;tctx.fillRect(0,0,w,h)}
        
        dom.ctx.clearRect(0,0,dom.canvas.width,dom.canvas.height); 
        dom.ctx.drawImage(tmpCanvas,0,0); 
        dom.status.textContent=`Vista previa actualizada a las ${new Date().toLocaleTimeString()}`;
        
        // Actualizar histogramas
        const finalImageData = dom.ctx.getImageData(0, 0, dom.canvas.width, dom.canvas.height);
        const histogram = calculateHistogram(finalImageData);
        drawHistogram(dom.histogramCanvas, histogram);
        drawHistogram(dom.overlayHistogram, histogram);
    };
    let drawTimeout = null;
    const scheduleDraw = (immediate = false) => {
        if(drawTimeout) clearTimeout(drawTimeout);
        
        if(immediate) {
            if(!appState.drawPending) {
                appState.drawPending = true;
                requestAnimationFrame(() => {
                    appState.drawPending = false;
                    drawPreview();
                });
            }
        } else {
            // Delay m√°s largo para sliders de color
            const delay = colorSystem && colorSystem.hasActiveChanges() ? 150 : 16;
            drawTimeout = setTimeout(() => {
                if(!appState.drawPending) {
                    appState.drawPending = true;
                    requestAnimationFrame(() => {
                        appState.drawPending = false;
                        drawPreview();
                    });
                }
            }, delay);
        }
    };

    // --- L√≥gica de Curvas Tonales Profesionales ---
    const curveState = { 
        channels: {
            rgb: [{x: 0, y: 0}, {x: 255, y: 255}],
            red: [{x: 0, y: 0}, {x: 255, y: 255}],
            green: [{x: 0, y: 0}, {x: 255, y: 255}],
            blue: [{x: 0, y: 0}, {x: 255, y: 255}],
            luminance: [{x: 0, y: 0}, {x: 255, y: 255}]
        },
        currentChannel: 'rgb',
        dragging: null,
        hoverPoint: null,
        mousePos: {x: 0, y: 0}
    };
    
    const curvePresets = {
        linear: [{x: 0, y: 0}, {x: 255, y: 255}],
        'slight-s': [{x: 0, y: 0}, {x: 64, y: 48}, {x: 128, y: 128}, {x: 192, y: 208}, {x: 255, y: 255}],
        'strong-s': [{x: 0, y: 0}, {x: 64, y: 32}, {x: 128, y: 128}, {x: 192, y: 224}, {x: 255, y: 255}],
        film: [{x: 0, y: 16}, {x: 64, y: 72}, {x: 128, y: 140}, {x: 192, y: 200}, {x: 255, y: 240}]
    };
    
    let curveDrawCache = null;
    const drawCurves = () => {
        const canvas = dom.curvesCanvas;
        const ctx = canvas.getContext('2d');
        const w = canvas.width, h = canvas.height;
        
        // Fondo profesional estilo DaVinci Resolve
        const bgGradient = ctx.createLinearGradient(0, 0, 0, h);
        bgGradient.addColorStop(0, '#2c2c2c');
        bgGradient.addColorStop(1, '#1e1e1e');
        ctx.fillStyle = bgGradient;
        ctx.fillRect(0, 0, w, h);
        
        // Marco biselado profesional
        ctx.strokeStyle = '#404040';
        ctx.lineWidth = 1;
        ctx.strokeRect(0.5, 0.5, w-1, h-1);
        
        ctx.strokeStyle = '#0a0a0a';
        ctx.strokeRect(1.5, 1.5, w-3, h-3);
        
        // √Årea de trabajo con gradiente sutil
        const workGradient = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, Math.max(w,h)/2);
        workGradient.addColorStop(0, '#262626');
        workGradient.addColorStop(1, '#1a1a1a');
        ctx.fillStyle = workGradient;
        ctx.fillRect(2, 2, w-4, h-4);
        
        // Grid profesional de precisi√≥n
        ctx.strokeStyle = '#3a3a3a';
        ctx.lineWidth = 0.8;
        
        // Grid principal (cuartos)
        for(let i = 1; i < 4; i++) {
            const x = (w / 4) * i, y = (h / 4) * i;
            ctx.beginPath(); ctx.moveTo(x, 2); ctx.lineTo(x, h-2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(2, y); ctx.lineTo(w-2, y); ctx.stroke();
        }
        
        // Grid de precisi√≥n (octavos)
        ctx.strokeStyle = '#2e2e2e';
        ctx.lineWidth = 0.4;
        for(let i = 1; i < 8; i++) {
            if(i % 2 !== 0) {
                const x = (w / 8) * i, y = (h / 8) * i;
                ctx.beginPath(); ctx.moveTo(x, 2); ctx.lineTo(x, h-2); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(2, y); ctx.lineTo(w-2, y); ctx.stroke();
            }
        }
        
        // L√≠nea diagonal de referencia profesional
        ctx.strokeStyle = '#505050';
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 2]);
        ctx.beginPath(); ctx.moveTo(2, h-2); ctx.lineTo(w-2, 2); ctx.stroke();
        ctx.setLineDash([]);
        
        // Curva principal
        const currentPoints = curveState.channels[curveState.currentChannel];
        const sortedPoints = [...currentPoints].sort((a, b) => a.x - b.x);
        
        // Colores profesionales estilo DaVinci
        const channelColors = {
            rgb: '#ffffff',
            red: '#ff6b6b',
            green: '#51cf66',
            blue: '#74c0fc',
            luminance: '#ced4da'
        };
        
        // Funci√≥n de interpolaci√≥n spline c√∫bica
        const getSplineValue = (inputVal) => {
            if(sortedPoints.length <= 2) {
                const t = inputVal / 255;
                return sortedPoints[0].y + t * (sortedPoints[1].y - sortedPoints[0].y);
            }
            
            for(let i = 0; i < sortedPoints.length - 1; i++) {
                const p1 = sortedPoints[i], p2 = sortedPoints[i + 1];
                if(inputVal >= p1.x && inputVal <= p2.x) {
                    const t = (inputVal - p1.x) / (p2.x - p1.x);
                    const t2 = t * t, t3 = t2 * t;
                    
                    let m0 = 0, m1 = 0;
                    if(i > 0) {
                        const p0 = sortedPoints[i - 1];
                        m0 = (p2.y - p0.y) / (p2.x - p0.x);
                    }
                    if(i < sortedPoints.length - 2) {
                        const p3 = sortedPoints[i + 2];
                        m1 = (p3.y - p1.y) / (p3.x - p1.x);
                    }
                    
                    const h00 = 2*t3 - 3*t2 + 1;
                    const h10 = t3 - 2*t2 + t;
                    const h01 = -2*t3 + 3*t2;
                    const h11 = t3 - t2;
                    
                    const dx = p2.x - p1.x;
                    return h00 * p1.y + h10 * dx * m0 + h01 * p2.y + h11 * dx * m1;
                }
            }
            return inputVal;
        };
        
        // Sombra de la curva para profundidad
        const baseColor = channelColors[curveState.currentChannel];
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
        ctx.lineWidth = 4;
        ctx.beginPath();
        
        for(let x = 2; x <= w-2; x += 1) {
            const inputVal = ((x-2) / (w-4)) * 255;
            const outputVal = getSplineValue(inputVal);
            const y = (h-2) - (Math.max(0, Math.min(255, outputVal)) / 255) * (h-4) + 1;
            if(x === 2) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        }
        ctx.stroke();
        
        // Curva principal con glow
        ctx.shadowColor = baseColor;
        ctx.shadowBlur = 3;
        ctx.strokeStyle = baseColor;
        ctx.lineWidth = 2.5;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();
        
        for(let x = 2; x <= w-2; x += 1) {
            const inputVal = ((x-2) / (w-4)) * 255;
            const outputVal = getSplineValue(inputVal);
            const y = (h-2) - (Math.max(0, Math.min(255, outputVal)) / 255) * (h-4);
            if(x === 2) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        }
        ctx.stroke();
        
        // Reset shadow
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        
        // Puntos de control profesionales estilo DaVinci
        currentPoints.forEach((point, i) => {
            const x = 2 + (point.x / 255) * (w-4);
            const y = (h-2) - (point.y / 255) * (h-4);
            const isActive = (i === curveState.hoverPoint || i === curveState.dragging);
            const isEndpoint = (i === 0 || i === currentPoints.length - 1);
            
            // Sombra del punto
            ctx.shadowColor = 'rgba(0, 0, 0, 0.6)';
            ctx.shadowBlur = isActive ? 8 : 4;
            ctx.shadowOffsetX = 1;
            ctx.shadowOffsetY = 1;
            
            // Anillo exterior
            const outerGradient = ctx.createRadialGradient(x, y, 0, x, y, isActive ? 7 : 5);
            outerGradient.addColorStop(0, '#666666');
            outerGradient.addColorStop(0.8, '#333333');
            outerGradient.addColorStop(1, '#1a1a1a');
            
            ctx.fillStyle = outerGradient;
            ctx.beginPath();
            ctx.arc(x, y, isActive ? 7 : 5, 0, Math.PI * 2);
            ctx.fill();
            
            // Punto principal
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            const pointGradient = ctx.createRadialGradient(x-1, y-1, 0, x, y, isActive ? 5 : 3);
            
            if(isEndpoint) {
                pointGradient.addColorStop(0, '#888888');
                pointGradient.addColorStop(1, '#555555');
            } else {
                pointGradient.addColorStop(0, baseColor);
                pointGradient.addColorStop(1, baseColor + '88');
            }
            
            ctx.fillStyle = pointGradient;
            ctx.beginPath();
            ctx.arc(x, y, isActive ? 5 : 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Punto interior brillante
            ctx.fillStyle = isActive ? '#ffffff' : 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(x-0.5, y-0.5, isActive ? 2 : 1, 0, Math.PI * 2);
            ctx.fill();
            
            // Anillo de selecci√≥n
            if(isActive) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(x, y, 9, 0, Math.PI * 2);
                ctx.stroke();
            }
        });
    };
    
    const initCurves = () => {
        const canvas = dom.curvesCanvas;
        const curveInfo = document.getElementById('curveInfo');
        drawCurves();
        
        // Selector de canal optimizado
        const channelSelect = document.getElementById('curveChannel');
        channelSelect.addEventListener('change', (e) => {
            curveState.currentChannel = e.target.value;
            drawCurves();
        });
        
        // Presets de curvas optimizados
        document.querySelectorAll('.curve-preset-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const preset = e.target.dataset.preset;
                if(curvePresets[preset]) {
                    curveState.channels[curveState.currentChannel] = curvePresets[preset].slice();
                    curveCache.dirty[curveState.currentChannel] = true;
                    drawCurves();
                    scheduleDraw(true);
                    
                    document.querySelectorAll('.curve-preset-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                }
            });
        });
        
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = ((e.clientX - rect.left) / rect.width) * 255;
            const y = 255 - ((e.clientY - rect.top) / rect.height) * 255;
            
            const currentPoints = curveState.channels[curveState.currentChannel];
            let closestPoint = null, minDist = 400;
            
            for(let i = 0; i < currentPoints.length; i++) {
                const point = currentPoints[i];
                const px = (point.x / 255) * rect.width;
                const py = rect.height - (point.y / 255) * rect.height;
                const mx = (x / 255) * rect.width;
                const my = rect.height - (y / 255) * rect.height;
                const dist = (px - mx) ** 2 + (py - my) ** 2;
                
                if(dist < minDist) {
                    closestPoint = i;
                    minDist = dist;
                }
            }
            
            if(closestPoint !== null && minDist < 400) {
                curveState.dragging = closestPoint;
            } else if(currentPoints.length < 16) {
                const newPoint = {x: Math.max(0, Math.min(255, x)), y: Math.max(0, Math.min(255, y))};
                currentPoints.push(newPoint);
                curveState.dragging = currentPoints.length - 1;
                curveCache.dirty[curveState.currentChannel] = true;
                drawCurves();
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = ((e.clientX - rect.left) / rect.width) * 255;
            const y = 255 - ((e.clientY - rect.top) / rect.height) * 255;
            
            if(curveInfo) curveInfo.textContent = `Input: ${Math.round(x)}, Output: ${Math.round(y)}`;
            
            const currentPoints = curveState.channels[curveState.currentChannel];
            
            if(curveState.dragging !== null) {
                const point = currentPoints[curveState.dragging];
                
                // Movimiento libre instant√°neo
                point.x = Math.max(0, Math.min(255, x));
                point.y = Math.max(0, Math.min(255, y));
                
                curveCache.dirty[curveState.currentChannel] = true;
                drawCurves();
            } else {
                let hoverPoint = null;
                const threshold = 20;
                
                for(let i = 0; i < currentPoints.length; i++) {
                    const point = currentPoints[i];
                    const px = (point.x / 255) * rect.width;
                    const py = rect.height - (point.y / 255) * rect.height;
                    const mx = (x / 255) * rect.width;
                    const my = rect.height - (y / 255) * rect.height;
                    
                    if(Math.abs(px - mx) < threshold && Math.abs(py - my) < threshold) {
                        hoverPoint = i;
                        break;
                    }
                }
                
                if(curveState.hoverPoint !== hoverPoint) {
                    curveState.hoverPoint = hoverPoint;
                    canvas.style.cursor = hoverPoint !== null ? 'pointer' : 'crosshair';
                    drawCurves();
                }
            }
        });
        
        canvas.addEventListener('mouseup', () => { 
            if(curveState.dragging !== null) {
                curveState.dragging = null;
                canvas.style.cursor = 'crosshair';
                // Final update al soltar
                scheduleDraw(true);
            }
        });
        
        canvas.addEventListener('mouseleave', () => {
            curveState.hoverPoint = null;
            canvas.style.cursor = 'crosshair';
            drawCurves();
        });
        
        canvas.addEventListener('dblclick', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = ((e.clientX - rect.left) / rect.width) * 255;
            const y = 255 - ((e.clientY - rect.top) / rect.height) * 255;
            
            const currentPoints = curveState.channels[curveState.currentChannel];
            const newPoints = currentPoints.filter((point, i) => {
                const px = (point.x / 255) * rect.width;
                const py = rect.height - (point.y / 255) * rect.height;
                const mx = (x / 255) * rect.width;
                const my = rect.height - (y / 255) * rect.height;
                const dist = Math.sqrt((px - mx) ** 2 + (py - my) ** 2);
                const isEndpoint = (i === 0 || i === currentPoints.length - 1);
                return dist >= 20 || isEndpoint || currentPoints.length <= 2;
            });
            
            curveState.channels[curveState.currentChannel] = newPoints;
            drawCurves(); scheduleDraw();
        });
    };

    // Funci√≥n para actualizar informaci√≥n de imagen
    const updateImageInfo = () => {
      try {
        const dimEl = document.getElementById('image-dimensions');
        const formatEl = document.getElementById('image-format');
        const sizeEl = document.getElementById('image-size');
        const brightnessEl = document.getElementById('avg-brightness');
        const saturationEl = document.getElementById('avg-saturation');
        const colorsEl = document.getElementById('dominant-colors');
        
        if (!appState.image.instance.complete || !dimEl) {
          if (dimEl) dimEl.textContent = '--';
          if (formatEl) formatEl.textContent = '--';
          if (sizeEl) sizeEl.textContent = '--';
          if (brightnessEl) brightnessEl.textContent = '--';
          if (saturationEl) saturationEl.textContent = '--';
          if (colorsEl) colorsEl.innerHTML = '';
          return;
        }
        
        const img = appState.image.instance;
        
        dimEl.textContent = `${img.naturalWidth || img.width} √ó ${img.naturalHeight || img.height}`;
        formatEl.textContent = img.src.includes('data:') ? 'Local' : 'Web';
        
        const pixels = (img.naturalWidth || img.width) * (img.naturalHeight || img.height);
        const sizeText = pixels > 1000000 ? `${(pixels/1000000).toFixed(1)}MP` : `${Math.round(pixels/1000)}K`;
        sizeEl.textContent = sizeText;
        
        const canvas = document.createElement('canvas');
        const size = Math.min(100, img.naturalWidth || img.width, img.naturalHeight || img.height);
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, size, size);
        
        const imageData = ctx.getImageData(0, 0, size, size);
        const data = imageData.data;
        
        let totalBrightness = 0;
        let totalSaturation = 0;
        const colorCounts = {};
        
        for (let i = 0; i < data.length; i += 4) {
          const r = data[i], g = data[i + 1], b = data[i + 2];
          
          totalBrightness += 0.299 * r + 0.587 * g + 0.114 * b;
          
          const max = Math.max(r, g, b), min = Math.min(r, g, b);
          totalSaturation += max > 0 ? (max - min) / max : 0;
          
          const colorKey = `${Math.floor(r/40)*40},${Math.floor(g/40)*40},${Math.floor(b/40)*40}`;
          colorCounts[colorKey] = (colorCounts[colorKey] || 0) + 1;
        }
        
        const pixelCount = data.length / 4;
        brightnessEl.textContent = `${Math.round(totalBrightness / pixelCount)}/255`;
        saturationEl.textContent = `${Math.round((totalSaturation / pixelCount) * 100)}%`;
        
        const dominantColors = Object.entries(colorCounts)
          .sort(([,a], [,b]) => b - a)
          .slice(0, 5);
        
        colorsEl.innerHTML = '';
        dominantColors.forEach(([color]) => {
          const [r, g, b] = color.split(',').map(Number);
          const div = document.createElement('div');
          div.style.cssText = `width: 20px; height: 20px; background: rgb(${r},${g},${b}); border-radius: 3px; border: 1px solid #555; display: inline-block;`;
          div.title = `rgb(${r},${g},${b})`;
          colorsEl.appendChild(div);
        });
      } catch (e) {
        console.warn('Error updating image info:', e);
      }
    };
    window.updateImageInfo = updateImageInfo;
    
    // --- L√≥gica de Imagen ---
    const generateImageRecommendation = () => {
        const recommendations = [
            'üì∏ ¬°Nueva imagen cargada! Te sugiero probar un "tono c√°lido" para darle vida.',
            'üé® ¬°Imagen lista! ¬øQu√© tal un estilo "vintage" para esta foto?',
            '‚ú® ¬°Perfecto! Podr√≠as probar "m√°s contraste" para resaltar los detalles.',
            'üåÖ ¬°Imagen cargada! Un "tono dram√°tico" podr√≠a quedar genial.',
            'üé≠ ¬°Lista para editar! Te recomiendo un estilo "suave y natural".',
            'üåü ¬°Nueva foto! ¬øProbamos con "colores vibrantes"?',
            'üì∑ ¬°Imagen cargada! Un "look cinematogr√°fico" podr√≠a ser interesante.',
            'üé™ ¬°Perfecto! ¬øQu√© tal un estilo "retro" para esta imagen?'
        ];
        
        // Personalizar recomendaci√≥n basada en preferencias
        let personalizedRec = recommendations[Math.floor(Math.random() * recommendations.length)];
        
        if(Object.keys(learningData.stylePreferences).length > 0) {
            const topPref = Object.entries(learningData.stylePreferences)
                .sort(([,a], [,b]) => Math.abs(b) - Math.abs(a))[0];
            
            if(topPref && Math.abs(topPref[1]) > 10) {
                personalizedRec += ` Bas√°ndome en tus preferencias, tambi√©n podr√≠as probar ajustar ${topPref[0]}.`;
            }
        }
        
        addMessageToChat(personalizedRec, 'bot');
    };
    
    const loadImage = (src) => { 
        dom.status.textContent='Cargando...';drawPlaceholder('Cargando imagen...'); 
        return new Promise((resolve,reject)=>{
            appState.image.instance.onload=resolve;
            appState.image.instance.onerror=reject;
            appState.image.instance.src=src;
        }).then(()=>{
            dom.status.textContent='Imagen cargada exitosamente.';
            scheduleDraw();
            
            // Actualizar informaci√≥n de imagen
            if(window.updateImageInfo) {
                setTimeout(() => window.updateImageInfo(), 100);
            }
            
            // Generar recomendaci√≥n inteligente solo si no es la imagen por defecto
            if(src !== DEFAULT_IMAGE_SRC) {
                setTimeout(() => {
                    const smartRec = analyzeImageForRecommendation();
                    if(smartRec && smartRec.preset) {
                        const suggestions = generateSmartSuggestions();
                        let message = 'üéØ **Nueva imagen detectada!** ';
                        
                        if(smartRec.imageType) {
                            message += `Veo que es ${smartRec.imageType.description}. `;
                        }
                        
                        if(suggestions.length > 0) {
                            message += `\n\nüí° **Sugerencias r√°pidas:**\n${suggestions.slice(0, 3).join('\n')}`;
                        }
                        
                        message += '\n\nEscribe "recomendaci√≥n" para an√°lisis completo o "que ves" para descripci√≥n detallada.';
                        
                        addMessageToChat(message, 'bot');
                    } else {
                        generateImageRecommendation();
                    }
                }, 1000);
            }
        }).catch(e=>{
            dom.status.textContent='Error al cargar imagen.';
            log('Error de carga:',e);
            if(appState.image.instance.src!==DEFAULT_IMAGE_SRC)loadImage(DEFAULT_IMAGE_SRC);
        }); 
    };
    
    // --- L√≥gica de Presets, Exportaci√≥n y ZIP ---
    const getPresets = () => JSON.parse(localStorage.getItem(PRESET_KEY) || '{}');
    const savePresets = (presets) => localStorage.setItem(PRESET_KEY, JSON.stringify(presets));
    const applyPreset = (presetValues) => { 
      for (const id in presetValues) { 
        if (appState.ui.sliders[id]) { 
          const slider = appState.ui.sliders[id];
          let value = Number(presetValues[id]);
          value = Math.max(Number(slider.min), Math.min(Number(slider.max), value));
          appState.sliderValues[id] = value; 
          slider.value = value; 
          appState.ui.displays[id].textContent = value; 
        } 
      } 
      scheduleDraw(); 
    };
    const renderPresetList = () => {
        dom.presetList.innerHTML = '';
        const presets = getPresets();
        if (Object.keys(presets).length === 0) {
            dom.presetList.innerHTML = `<p class='text-sm' style='text-align:center; padding: 20px 0;'>No hay presets guardados.</p>`;
            return;
        }
        for (const name in presets) {
            const item = document.createElement('div');
            item.className = 'preset-item';
            item.innerHTML = `<input type="checkbox" data-preset-name="${escapeXml(name)}"><div class="preset-name">${escapeXml(name)}</div><button class="btn secondary">Cargar</button><button class="btn danger">Eliminar</button>`;
            dom.presetList.appendChild(item);
            const [_, __, loadBtn, delBtn] = item.children;
            loadBtn.onclick = () => { dom.presetName.value = name; applyPreset(presets[name]); };
            delBtn.onclick = () => { if (confirm(`¬øEliminar preset "${name}"?`)) { delete presets[name]; savePresets(presets); renderPresetList(); } };
        }
    };
    const buildXmp = (presetName, presetValues, mode) => { const crsName = k => ({exposure:'Exposure2012',contrast:'Contrast2012',saturation:'Saturation',highlights:'Highlights2012',shadows:'Shadows2012',whites:'Whites2012',blacks:'Blacks2012',clarity:'Clarity2012',vibrance:'Vibrance',sharpness:'SharpenRadius',temperature:'Temperature',tint:'Tint',vignette:'VignetteMidpoint'}[k]||k); let xml='<?xpacket begin="\uFEFF" id="W5M0MpCehiHzreSzNTczkc9d"?>\n<x:xmpmeta xmlns:x="adobe:ns:meta/">\n  <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">\n'; if(mode==='modern'){xml+=`    <rdf:Description rdf:about="" xmlns:crs="http://ns.adobe.com/camera-raw-settings/1.0/">\n      <crs:PresetType>Normal</crs:PresetType>\n      <crs:Cluster>${escapeXml(presetName)}</crs:Cluster>\n`;for(const k in presetValues)xml+=`      <crs:${crsName(k)}>${presetValues[k]}</crs:${crsName(k)}>\n`;xml+='    </rdf:Description>\n';}else{let attrs='';for(const k in presetValues)attrs+=` crs:${crsName(k)}="${presetValues[k]}"`;xml+=`    <rdf:Description rdf:about="" xmlns:crs="http://ns.adobe.com/camera-raw-settings/1.0/"${attrs} />\n`;} xml+='  </rdf:RDF>\n</x:xmpmeta>\n<?xpacket end="w"?>'; return xml; };
    const createZip = (entries) => { function crc32(buf){const table=crc32.table||(crc32.table=(()=>{const t=new Uint32Array(256);for(let i=0;i<256;i++){let c=i;for(let k=0;k<8;k++)c=((c&1)?(0xEDB88320^(c>>>1)):(c>>>1));t[i]=c>>>0}return t})());let crc=0^(-1);for(let i=0;i<buf.length;i++)crc=(crc>>>8)^table[(crc^buf[i])&0xff];return(crc^(-1))>>>0} let offset=0;const chunks=[];const centralDir=[];function writeLE(n,bytes){const arr=new Uint8Array(bytes);for(let i=0;i<bytes;i++){arr[i]=n&0xff;n=n>>>8}return arr} entries.forEach(entry=>{const nameU=str2utf8uint8(entry.name);const data=entry.data;const crc=crc32(data);const localHeader=new Uint8Array(30+nameU.length);localHeader.set(writeLE(0x04034b50,4),0);localHeader.set(writeLE(20,2),4);localHeader.set(writeLE(0,2),6);localHeader.set(writeLE(0,2),8);localHeader.set(writeLE(0,2),10);localHeader.set(writeLE(0,2),12);localHeader.set(writeLE(crc,4),14);localHeader.set(writeLE(data.length,4),18);localHeader.set(writeLE(data.length,4),22);localHeader.set(writeLE(nameU.length,2),26);localHeader.set(writeLE(0,2),28);localHeader.set(nameU,30);chunks.push(localHeader);chunks.push(data);const centralHeader=new Uint8Array(46+nameU.length);centralHeader.set(writeLE(0x02014b50,4),0);centralHeader.set(writeLE(0x0317,2),4);centralHeader.set(writeLE(20,2),6);centralHeader.set(writeLE(0,2),8);centralHeader.set(writeLE(0,2),10);centralHeader.set(writeLE(0,2),12);centralHeader.set(writeLE(0,2),14);centralHeader.set(writeLE(crc,4),16);centralHeader.set(writeLE(data.length,4),20);centralHeader.set(writeLE(data.length,4),24);centralHeader.set(writeLE(nameU.length,2),28);centralHeader.set(writeLE(0,2),30);centralHeader.set(writeLE(0,2),32);centralHeader.set(writeLE(0,4),34);centralHeader.set(writeLE(0,4),38);centralHeader.set(writeLE(offset,4),42);centralHeader.set(nameU,46);centralDir.push(centralHeader);offset+=localHeader.length+data.length});const centralSize=centralDir.reduce((s,c)=>s+c.length,0);const eocd=new Uint8Array(22);eocd.set(writeLE(0x06054b50,4),0);eocd.set(writeLE(0,2),4);eocd.set(writeLE(0,2),6);eocd.set(writeLE(centralDir.length,2),8);eocd.set(writeLE(centralDir.length,2),10);eocd.set(writeLE(centralSize,4),12);eocd.set(writeLE(offset,4),16);eocd.set(writeLE(0,2),20);chunks.push(...centralDir,eocd);return new Blob(chunks,{type:'application/zip'}); };
    
    // ===== L√ìGICA DE IA Y CHATBOT MODIFICADA =====
    const extractJson = (text) => { const s=text.indexOf('{'),e=text.lastIndexOf('}');if(s===-1||e===-1)return null;return text.slice(s,e+1); };
    const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

    async function callAi(userPrompt, retries = 2, delay = 5000) {
        try {
            const apiKey = getUserApiKey();
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{
                        parts: [{
                            text: `Eres un generador de presets para Lightroom. Responde S√ìLO con JSON v√°lido. Todos los valores deben estar entre -100 y 100, donde 0 es neutral. IMPORTANTE: Para tonos c√°lidos/rojos/naranjas usa temperature positivo (+30 a +80). Para tonos fr√≠os/azules usa temperature negativo (-30 a -80). Para "${userPrompt}" genera valores apropiados.`
                        }]
                    }]
                })
            });

            if (!response.ok) {
                if (response.status === 429 && retries > 0) {
                    log(`Error 429. Retrying in ${delay / 1000}s... (${retries - 1} retries left)`);
                    updateTypingIndicator(`L√≠mite alcanzado. Esperando ${delay/1000}s antes de reintentar...`);
                    await sleep(delay);
                    return callAi(userPrompt, retries - 1, delay * 1.5);
                }
                throw new Error(`Error de red: ${response.status}`);
            }

            const data = await response.json();
            const text = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
            const j = extractJson(text);
            if (!j) throw new Error('La respuesta de la IA no conten√≠a JSON.');
            return JSON.parse(j);
        } catch (e) {
            throw e;
        }
    };
    
    const addMessageToChat = (text, sender, isTyping = false) => {
        const messageEl = document.createElement('div');
        if (isTyping) {
            messageEl.className = 'typing-indicator';
            messageEl.innerHTML = `<span></span><span></span><span></span> <span class="typing-text"></span>`;
            messageEl.id = 'typingIndicator';
        } else {
            messageEl.className = `chat-message ${sender}-message`;
            messageEl.textContent = text;
            
            // Guardar en historial (solo mensajes reales, no typing)
            if (!isTyping) {
                conversationHistory.push({
                    text: text,
                    sender: sender,
                    timestamp: new Date().toISOString(),
                    session: Date.now()
                });
                // Mantener solo √∫ltimas 50 conversaciones
                if (conversationHistory.length > 50) {
                    conversationHistory = conversationHistory.slice(-50);
                }
                localStorage.setItem('chatHistory', JSON.stringify(conversationHistory));
                
                // Actualizar estad√≠sticas
                if (sender === 'user') sessionStats.messagesCount++;
            }
        }
        dom.chatMessages.appendChild(messageEl);
        // Scroll suave que mantiene visible el √°rea de entrada
        setTimeout(() => {
            dom.chatMessages.scrollTop = dom.chatMessages.scrollHeight;
        }, 100);
    };

    const updateTypingIndicator = (text) => {
        const typingText = document.querySelector('#typingIndicator .typing-text');
        if(typingText) {
            typingText.textContent = text;
        }
    };

    // Estado del chatbot avanzado
    let pendingRecommendation = null;
    let conversationHistory = JSON.parse(localStorage.getItem('chatHistory') || '[]');
    let sessionStats = { messagesCount: 0, imagesAnalyzed: 0, presetsApplied: 0, commandsExecuted: 0, tutorialsViewed: 0 };
    let userPreferences = JSON.parse(localStorage.getItem('userPreferences') || '{}');
    let imageAnalysisCache = new Map();
    let lastImageHash = null;
    let smartSuggestions = [];
    let learningData = JSON.parse(localStorage.getItem('learningData') || '{ "stylePreferences": {}, "frequentAdjustments": {}, "imageTypes": {} }');
    
    // Sistema de an√°lisis visual inteligente mejorado
    const generateImageHash = (imageData) => {
        let hash = 0;
        for(let i = 0; i < imageData.data.length; i += 400) {
            hash = ((hash << 5) - hash + imageData.data[i]) & 0xffffffff;
        }
        return hash.toString();
    };
    
    const analyzeImageForRecommendation = () => {
        if (!appState.image.instance.complete) return null;
        
        const canvas = document.createElement('canvas');
        canvas.width = 200; canvas.height = 200;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(appState.image.instance, 0, 0, 200, 200);
        
        const imageData = ctx.getImageData(0, 0, 200, 200);
        const imageHash = generateImageHash(imageData);
        
        // Cache de an√°lisis para evitar rec√°lculos
        if (imageAnalysisCache.has(imageHash)) {
            const cached = imageAnalysisCache.get(imageHash);
            return cached.recommendation ? applyLearningToRecommendation(cached.recommendation) : cached;
        }
        
        const data = imageData.data;
        
        // An√°lisis avanzado con detecci√≥n de problemas
        let brightness = 0, contrast = 0, saturation = 0;
        let rTotal = 0, gTotal = 0, bTotal = 0;
        let darkPixels = 0, brightPixels = 0, midtonePixels = 0;
        let colorfulness = 0, warmth = 0;
        let edgePixels = 0, noiseLevel = 0;
        const histogram = { r: new Array(256).fill(0), g: new Array(256).fill(0), b: new Array(256).fill(0) };
        
        // An√°lisis de problemas t√©cnicos
        let clippedHighlights = 0, clippedShadows = 0;
        let colorCast = { red: 0, green: 0, blue: 0 };
        
        for(let i = 0; i < data.length; i += 4) {
            const r = data[i], g = data[i+1], b = data[i+2];
            const gray = 0.299*r + 0.587*g + 0.114*b;
            
            brightness += gray;
            histogram.r[r]++; histogram.g[g]++; histogram.b[b]++;
            
            // Detecci√≥n de clipping
            if(r >= 250 && g >= 250 && b >= 250) clippedHighlights++;
            if(r <= 5 && g <= 5 && b <= 5) clippedShadows++;
            
            // An√°lisis de distribuci√≥n tonal
            if(gray < 85) darkPixels++;
            else if(gray > 170) brightPixels++;
            else midtonePixels++;
            
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            saturation += max > 0 ? (max - min) / max : 0;
            colorfulness += Math.abs(r - gray) + Math.abs(g - gray) + Math.abs(b - gray);
            
            // An√°lisis de temperatura de color y dominantes
            warmth += (r - b) / 255;
            colorCast.red += r - gray;
            colorCast.green += g - gray;
            colorCast.blue += b - gray;
            
            // Detecci√≥n de ruido (simplificada)
            if(i > 800 && i < data.length - 800) {
                const prevGray = 0.299*data[i-4] + 0.587*data[i-3] + 0.114*data[i-2];
                if(Math.abs(gray - prevGray) > 30) noiseLevel++;
            }
            
            rTotal += r; gTotal += g; bTotal += b;
        }
        
        const pixels = data.length / 4;
        brightness /= pixels;
        saturation /= pixels;
        colorfulness /= pixels;
        warmth /= pixels;
        noiseLevel /= pixels;
        
        const darkRatio = darkPixels / pixels;
        const brightRatio = brightPixels / pixels;
        const midtoneRatio = midtonePixels / pixels;
        const clippingRatio = (clippedHighlights + clippedShadows) / pixels;
        
        const analysis = {
            brightness, saturation, colorfulness, warmth,
            darkRatio, brightRatio, midtoneRatio, clippingRatio, noiseLevel,
            avgR: rTotal / pixels, avgG: gTotal / pixels, avgB: bTotal / pixels,
            colorCast, clippedHighlights: clippedHighlights / pixels, clippedShadows: clippedShadows / pixels
        };
        
        // Detectar tipo de imagen y problemas
        const imageType = detectImageType(analysis);
        const problems = detectImageProblems(analysis);
        
        const recommendation = generateSmartRecommendation(imageType, analysis, problems);
        
        // Guardar en cache
        imageAnalysisCache.set(imageHash, { imageType, analysis, problems, recommendation });
        lastImageHash = imageHash;
        
        return applyLearningToRecommendation({ imageType, analysis, problems, recommendation });
    };
    
    // Detecci√≥n de problemas t√©cnicos
    const detectImageProblems = (analysis) => {
        const problems = [];
        
        if(analysis.clippedHighlights > 0.05) problems.push({ type: 'overexposure', severity: 'high', message: 'Luces quemadas detectadas' });
        if(analysis.clippedShadows > 0.05) problems.push({ type: 'underexposure', severity: 'high', message: 'Sombras empastadas detectadas' });
        if(analysis.brightness < 60) problems.push({ type: 'dark', severity: 'medium', message: 'Imagen muy oscura' });
        if(analysis.brightness > 220) problems.push({ type: 'bright', severity: 'medium', message: 'Imagen muy clara' });
        if(analysis.noiseLevel > 0.15) problems.push({ type: 'noise', severity: 'medium', message: 'Ruido digital detectado' });
        if(Math.abs(analysis.warmth) > 0.2) problems.push({ type: 'colorcast', severity: 'low', message: 'Dominante de color detectada' });
        if(analysis.saturation < 0.1) problems.push({ type: 'desaturated', severity: 'low', message: 'Colores muy apagados' });
        
        return problems;
    };
    
    // Sistema de aprendizaje de preferencias
    const applyLearningToRecommendation = (data) => {
        // Si es un objeto completo con recommendation, extraer la recomendaci√≥n
        const recommendation = data.recommendation || data;
        if(!recommendation || !recommendation.preset) return recommendation;
        
        // Aplicar preferencias aprendidas
        const learned = learningData.stylePreferences;
        const adjustedPreset = { ...recommendation.preset };
        
        // Si el usuario tiende a preferir m√°s contraste, ajustar
        if(learned.contrast && learned.contrast > 0) {
            adjustedPreset.contrast = (adjustedPreset.contrast || 0) + Math.min(learned.contrast * 0.3, 15);
        }
        
        // Si prefiere tonos m√°s c√°lidos
        if(learned.temperature && learned.temperature > 0) {
            adjustedPreset.temperature = (adjustedPreset.temperature || 0) + Math.min(learned.temperature * 0.2, 10);
        }
        
        // Aplicar ajustes frecuentes
        Object.keys(learningData.frequentAdjustments).forEach(key => {
            const freq = learningData.frequentAdjustments[key];
            if(freq > 5 && adjustedPreset[key] !== undefined) {
                adjustedPreset[key] = Math.round((adjustedPreset[key] + freq * 0.1) * 10) / 10;
            }
        });
        
        const result = { ...recommendation, preset: adjustedPreset, isPersonalized: true };
        // Si tenemos datos adicionales, incluirlos
        if(data.imageType) result.imageType = data.imageType;
        if(data.analysis) result.analysis = data.analysis;
        if(data.problems) result.problems = data.problems;
        return result;
    };
    
    // Aprender de las acciones del usuario
    const learnFromUserAction = (action, values) => {
        if(action === 'preset_applied') {
            Object.keys(values).forEach(key => {
                if(!learningData.frequentAdjustments[key]) learningData.frequentAdjustments[key] = 0;
                learningData.frequentAdjustments[key] += Math.abs(values[key]) * 0.1;
            });
        }
        
        if(action === 'style_preference') {
            Object.keys(values).forEach(key => {
                if(!learningData.stylePreferences[key]) learningData.stylePreferences[key] = 0;
                learningData.stylePreferences[key] = (learningData.stylePreferences[key] * 0.8) + (values[key] * 0.2);
            });
        }
        
        localStorage.setItem('learningData', JSON.stringify(learningData));
    };
    
    const describeImage = (imageType, analysis) => {
        const { type, description, confidence } = imageType;
        const { brightness, saturation, warmth, darkRatio, brightRatio, colorfulness } = analysis;
        
        let technicalDesc = "";
        if (brightness < 80) technicalDesc = "La imagen est√° subexpuesta con tonos oscuros dominantes.";
        else if (brightness > 200) technicalDesc = "La imagen est√° sobreexpuesta con tonos muy claros.";
        else technicalDesc = "La exposici√≥n est√° bien equilibrada.";
        
        let colorDesc = "";
        if (saturation < 0.2) colorDesc = " Los colores son muy sutiles o monocrom√°ticos.";
        else if (saturation > 0.6) colorDesc = " Los colores son muy vibrantes y saturados.";
        else colorDesc = " Los colores tienen una saturaci√≥n natural.";
        
        let warmthDesc = "";
        if (warmth > 0.1) warmthDesc = " Predominan los tonos c√°lidos (rojos/naranjas).";
        else if (warmth < -0.1) warmthDesc = " Predominan los tonos fr√≠os (azules).";
        else warmthDesc = " Los tonos de color est√°n equilibrados.";
        
        switch(type) {
            case 'cielo':
                return `üå§Ô∏è **Descripci√≥n de imagen**: Veo un ${description} con tonos azulados caracter√≠sticos. ${technicalDesc}${colorDesc}${warmthDesc} La composici√≥n sugiere un paisaje abierto con buen rango din√°mico.`;
            case 'naturaleza':
                return `üåø **Descripci√≥n de imagen**: Identifico ${description} con predominancia de verdes naturales. ${technicalDesc}${colorDesc} La imagen muestra texturas org√°nicas y detalles naturales.`;
            case 'retrato':
                return `üë§ **Descripci√≥n de imagen**: Detecto un ${description} con tonos de piel visibles. ${technicalDesc}${warmthDesc} La iluminaci√≥n parece enfocada en el sujeto principal.`;
            case 'nocturna':
                return `üåô **Descripci√≥n de imagen**: Reconozco una ${description} con ${Math.round(darkRatio*100)}% de p√≠xeles oscuros. ${technicalDesc} La atm√≥sfera es dram√°tica y misteriosa.`;
            case 'highkey':
                return `‚òÄÔ∏è **Descripci√≥n de imagen**: Veo una ${description} con ${Math.round(brightRatio*100)}% de tonos claros. El estilo es luminoso y et√©reo, t√≠pico de fotograf√≠a high-key.`;
            case 'vibrante':
                return `üé® **Descripci√≥n de imagen**: Observo una ${description} con alta intensidad crom√°tica (${Math.round(colorfulness)}). Los colores son llamativos y energ√©ticos.`;
            case 'monocromatica':
                return `‚ö´ **Descripci√≥n de imagen**: Detecto una ${description} con paleta limitada. ${technicalDesc} El enfoque est√° en formas, texturas y contrastes tonales.`;
            default:
                return `üì∑ **Descripci√≥n de imagen**: Imagen de tipo general con caracter√≠sticas mixtas. ${technicalDesc}${colorDesc}${warmthDesc} Confianza de an√°lisis: ${Math.round(confidence*100)}%.`;
        }
    };
    
    const detectImageType = (analysis) => {
        const { brightness, saturation, colorfulness, warmth, darkRatio, brightRatio, avgR, avgG, avgB } = analysis;
        
        // Detecci√≥n de tipo de escena
        if(avgB > avgR + 15 && avgB > avgG + 10 && brightness > 120) {
            return { type: 'cielo', confidence: 0.8, description: 'paisaje con cielo' };
        }
        if(avgG > avgR + 10 && avgG > avgB + 10 && saturation > 0.4) {
            return { type: 'naturaleza', confidence: 0.7, description: 'vegetaci√≥n o naturaleza' };
        }
        if(warmth > 0.1 && brightness < 100 && colorfulness < 30) {
            return { type: 'retrato', confidence: 0.6, description: 'posible retrato con tonos c√°lidos' };
        }
        if(darkRatio > 0.6 && brightRatio < 0.1) {
            return { type: 'nocturna', confidence: 0.8, description: 'fotograf√≠a nocturna o low-key' };
        }
        if(brightRatio > 0.4 && saturation < 0.3) {
            return { type: 'highkey', confidence: 0.7, description: 'imagen high-key o sobreexpuesta' };
        }
        if(Math.abs(warmth) < 0.05 && saturation < 0.2) {
            return { type: 'monocromatica', confidence: 0.6, description: 'imagen con tonos neutros' };
        }
        if(colorfulness > 50 && saturation > 0.5) {
            return { type: 'vibrante', confidence: 0.7, description: 'imagen colorida y vibrante' };
        }
        
        return { type: 'general', confidence: 0.5, description: 'imagen general' };
    };
    
    const generateSmartRecommendation = (imageType, analysis, problems = []) => {
        const { type, description } = imageType;
        const { brightness, saturation, warmth, darkRatio, brightRatio } = analysis;
        
        // Generar recomendaci√≥n con problemas detectados
        let recommendation;
        
        switch(type) {
            case 'cielo':
                recommendation = {
                    text: `üå§Ô∏è **An√°lisis inteligente**: Detect√© un ${description}. Para realzar el cielo, sugiero aumentar el contraste (+20), reducir ligeramente los blancos (-15) y a√±adir vibrance (+30) para colores m√°s dram√°ticos.`,
                    preset: { contrast: 20, whites: -15, vibrance: 30, clarity: 15, highlights: -10 },
                    reason: "Optimizaci√≥n para paisaje con cielo"
                };
                break;
                
            case 'naturaleza':
                recommendation = {
                    text: `üåø **An√°lisis inteligente**: Identific√© ${description}. Recomiendo potenciar los verdes con vibrance (+25), a√±adir claridad (+20) para detalles de textura y ajustar sombras (+15) para revelar informaci√≥n.`,
                    preset: { vibrance: 25, clarity: 20, shadows: 15, saturation: 10, sharpness: 10 },
                    reason: "Optimizaci√≥n para naturaleza"
                };
                break;
                
            case 'retrato':
                recommendation = {
                    text: `üë§ **An√°lisis inteligente**: Detect√© un ${description}. Para retratos sugiero suavizar con claridad negativa (-10), calentar ligeramente (+10 temperatura) y equilibrar sombras (+20) para una piel m√°s favorecedora.`,
                    preset: { clarity: -10, temperature: 10, shadows: 20, highlights: -5, vibrance: 15 },
                    reason: "Optimizaci√≥n para retrato"
                };
                break;
                
            case 'nocturna':
                recommendation = {
                    text: `üåô **An√°lisis inteligente**: Identific√© una ${description}. Sugiero levantar sombras (+40), controlar ruido con claridad sutil (+5) y a√±adir contraste (+25) para dramatismo nocturno.`,
                    preset: { shadows: 40, clarity: 5, contrast: 25, blacks: -10, vibrance: 20 },
                    reason: "Optimizaci√≥n para fotograf√≠a nocturna"
                };
                break;
                
            case 'highkey':
                recommendation = {
                    text: `‚òÄÔ∏è **An√°lisis inteligente**: Detect√© una ${description}. Recomiendo reducir blancos (-30), aumentar contraste (+15) y a√±adir saturaci√≥n (+20) para recuperar definici√≥n sin perder el estilo high-key.`,
                    preset: { whites: -30, contrast: 15, saturation: 20, highlights: -20, clarity: 10 },
                    reason: "Correcci√≥n para imagen high-key"
                };
                break;
                
            case 'vibrante':
                recommendation = {
                    text: `üé® **An√°lisis inteligente**: Identificu√© una ${description}. Para mantener la vivacidad sin saturar, sugiero usar vibrance (+15) en lugar de saturaci√≥n, a√±adir contraste (+20) y claridad (+15).`,
                    preset: { vibrance: 15, contrast: 20, clarity: 15, highlights: -5, shadows: 10 },
                    reason: "Optimizaci√≥n para imagen colorida"
                };
                break;
                
            case 'monocromatica':
                recommendation = {
                    text: `‚ö´ **An√°lisis inteligente**: Detect√© una ${description}. Para im√°genes monocrom√°ticas sugiero enfocarse en contraste (+30), claridad (+25) y definici√≥n tonal con curvas.`,
                    preset: { contrast: 30, clarity: 25, whites: 10, blacks: -15, sharpness: 15 },
                    reason: "Optimizaci√≥n monocrom√°tica"
                };
                break;
                
            default:
                // An√°lisis cl√°sico mejorado
                if (brightness < 80) {
                    recommendation = {
                        text: `üìä **An√°lisis t√©cnico**: Imagen subexpuesta detectada. Sugiero exposici√≥n (+25), sombras (+30) y un toque de contraste (+10) para equilibrar la luminosidad.`,
                        preset: { exposure: 25, shadows: 30, contrast: 10 },
                        reason: "Correcci√≥n de subexposici√≥n"
                    };
                } else if (brightness > 200) {
                    recommendation = {
                        text: `üìä **An√°lisis t√©cnico**: Imagen sobreexpuesta. Recomiendo reducir exposici√≥n (-20), blancos (-25) y highlights (-15) para recuperar detalles perdidos.`,
                        preset: { exposure: -20, whites: -25, highlights: -15 },
                        reason: "Correcci√≥n de sobreexposici√≥n"
                    };
                } else {
                    recommendation = {
                        text: `üìä **An√°lisis t√©cnico**: Imagen bien expuesta. Sugiero optimizaci√≥n general con contraste (+15), claridad (+10) y nitidez (+5) para realzar detalles.`,
                        preset: { contrast: 15, clarity: 10, sharpness: 5 },
                        reason: "Optimizaci√≥n general"
                    };
                }
        }
        
        // Ajustar recomendaci√≥n basada en problemas detectados
        if(problems && problems.length > 0) {
            let problemText = "\n\nüîç **Problemas detectados**: ";
            problems.forEach(problem => {
                problemText += problem.message + ". ";
                
                // Ajustar preset seg√∫n problemas
                switch(problem.type) {
                    case 'overexposure':
                        recommendation.preset.highlights = Math.min((recommendation.preset.highlights || 0) - 30, -50);
                        recommendation.preset.whites = Math.min((recommendation.preset.whites || 0) - 20, -40);
                        break;
                    case 'underexposure':
                        recommendation.preset.shadows = Math.max((recommendation.preset.shadows || 0) + 40, 30);
                        recommendation.preset.blacks = Math.max((recommendation.preset.blacks || 0) + 15, 10);
                        break;
                    case 'noise':
                        recommendation.preset.clarity = Math.min((recommendation.preset.clarity || 0) - 10, -5);
                        recommendation.preset.sharpness = Math.min((recommendation.preset.sharpness || 0) - 5, 0);
                        break;
                    case 'colorcast':
                        if(warmth > 0.2) recommendation.preset.temperature = (recommendation.preset.temperature || 0) - 15;
                        if(warmth < -0.2) recommendation.preset.temperature = (recommendation.preset.temperature || 0) + 15;
                        break;
                }
            });
            
            recommendation.text += problemText;
        }
        
        return recommendation
    };
    
    const addMessageWithActions = (text, isRecommendation = false, preset = null) => {
        const messageEl = document.createElement('div');
        messageEl.className = `chat-message ${isRecommendation ? 'recommendation-message' : 'bot-message'}`;
        
        const textEl = document.createElement('div');
        textEl.textContent = text;
        messageEl.appendChild(textEl);
        
        if (isRecommendation && preset) {
            const actionsEl = document.createElement('div');
            actionsEl.className = 'action-buttons';
            
            const applyBtn = document.createElement('button');
            applyBtn.className = 'action-btn primary';
            applyBtn.textContent = '‚úì Aplicar';
            applyBtn.onclick = () => {
                applyPreset(preset);
                learnFromUserAction('preset_applied', preset); // Aprender de la acci√≥n
                learnFromUserAction('style_preference', preset); // Aprender preferencia de estilo
                sessionStats.presetsApplied++; // Actualizar estad√≠sticas
                addMessageToChat('¬°Recomendaci√≥n aplicada! Los ajustes se han actualizado seg√∫n el an√°lisis.', 'bot');
                pendingRecommendation = null;
            };
            
            const declineBtn = document.createElement('button');
            declineBtn.className = 'action-btn secondary';
            declineBtn.textContent = '‚úó No aplicar';
            declineBtn.onclick = () => {
                addMessageToChat('Entendido. ¬øHay alg√∫n estilo espec√≠fico que prefieras?', 'bot');
                pendingRecommendation = null;
            };
            
            actionsEl.appendChild(applyBtn);
            actionsEl.appendChild(declineBtn);
            messageEl.appendChild(actionsEl);
        }
        
        dom.chatMessages.appendChild(messageEl);
        // Scroll suave que mantiene visible el √°rea de entrada
        setTimeout(() => {
            dom.chatMessages.scrollTop = dom.chatMessages.scrollHeight;
        }, 100);
    };
    
    // Respuestas simples para conversaci√≥n b√°sica
    function getSimpleResponse(message) {
      const msg = message.toLowerCase();
      
      // Descripci√≥n de imagen (solo descripci√≥n, sin recomendaciones)
      if (msg.includes('que ves') || msg.includes('qu√© ves') || msg.includes('describe') || msg.includes('observas') || msg.includes('miras')) {
          if (!appState.image.instance.complete) {
              return "Hmm, no veo ninguna imagen cargada. ¬øPodr√≠as subir una foto primero? As√≠ podr√© contarte qu√© veo en ella üòä";
          }
          
          const canvas = document.createElement('canvas');
          canvas.width = 200; canvas.height = 200;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(appState.image.instance, 0, 0, 200, 200);
          
          const imageData = ctx.getImageData(0, 0, 200, 200);
          const data = imageData.data;
          
          let brightness = 0, saturation = 0, colorfulness = 0, warmth = 0;
          let darkPixels = 0, brightPixels = 0, midtonePixels = 0;
          let rTotal = 0, gTotal = 0, bTotal = 0;
          
          for(let i = 0; i < data.length; i += 4) {
              const r = data[i], g = data[i+1], b = data[i+2];
              const gray = 0.299*r + 0.587*g + 0.114*b;
              
              brightness += gray;
              if(gray < 85) darkPixels++;
              else if(gray > 170) brightPixels++;
              else midtonePixels++;
              
              const max = Math.max(r, g, b);
              const min = Math.min(r, g, b);
              saturation += max > 0 ? (max - min) / max : 0;
              colorfulness += Math.abs(r - gray) + Math.abs(g - gray) + Math.abs(b - gray);
              warmth += (r - b) / 255;
              
              rTotal += r; gTotal += g; bTotal += b;
          }
          
          const pixels = data.length / 4;
          const analysis = {
              brightness: brightness / pixels,
              saturation: saturation / pixels,
              colorfulness: colorfulness / pixels,
              warmth: warmth / pixels,
              darkRatio: darkPixels / pixels,
              brightRatio: brightPixels / pixels,
              midtoneRatio: midtonePixels / pixels,
              avgR: rTotal / pixels,
              avgG: gTotal / pixels,
              avgB: bTotal / pixels
          };
          
          const imageType = detectImageType(analysis);
          
          // Solo descripci√≥n, sin botones de acci√≥n
          let description = "";
          const { type, description: typeDesc } = imageType;
          const { brightness: avgBrightness, saturation: avgSat, warmth: avgWarmth, darkRatio, brightRatio, colorfulness: avgColor } = analysis;
          
          // Descripci√≥n visual m√°s natural
          description += `Veo una imagen realmente interesante. D√©jame contarte lo que observo:\n\n`;
          
          // Tipo de escena con lenguaje m√°s natural
          switch(type) {
              case 'cielo':
                  description += `üå§Ô∏è Me parece un paisaje hermoso con mucho cielo. Veo esos tonos azulados t√≠picos de los espacios abiertos.\n`;
                  break;
              case 'naturaleza':
                  description += `üåø ¬°Qu√© bonita! Es una foto de naturaleza con muchos verdes. Me encantan este tipo de im√°genes.\n`;
                  break;
              case 'retrato':
                  description += `üë§ Parece ser un retrato. Puedo ver tonos de piel, as√≠ que probablemente hay una persona en la foto.\n`;
                  break;
              case 'nocturna':
                  description += `üåô ¬°Wow! Es una foto nocturna con mucha atm√≥sfera. Las sombras le dan un toque muy dram√°tico.\n`;
                  break;
              case 'highkey':
                  description += `‚òÄÔ∏è Es una imagen muy luminosa y clara. Tiene ese estilo "high-key" que se ve s√∫per elegante.\n`;
                  break;
              case 'vibrante':
                  description += `üé® ¬°Qu√© colores tan vivos! Esta imagen tiene mucha energ√≠a y personalidad.\n`;
                  break;
              case 'monocromatica':
                  description += `‚ö´ Tiene una paleta de colores muy sutil. Me gusta este estilo minimalista.\n`;
                  break;
              default:
                  description += `üì∑ Es una imagen con caracter√≠sticas interesantes y variadas.\n`;
          }
          
          // An√°lisis m√°s conversacional
          description += `\nEn cuanto a los aspectos t√©cnicos:\n`;
          
          if (avgBrightness < 80) {
              description += `‚Ä¢ La imagen est√° un poco oscura, con bastantes sombras (como el ${Math.round(darkRatio*100)}% de la foto)\n`;
          } else if (avgBrightness > 200) {
              description += `‚Ä¢ Est√° bastante clara y luminosa (${Math.round(brightRatio*100)}% son tonos muy brillantes)\n`;
          } else {
              description += `‚Ä¢ La exposici√≥n se ve bien equilibrada, ni muy oscura ni muy clara\n`;
          }
          
          if (avgWarmth > 0.1) {
              description += `‚Ä¢ Tiene tonos c√°lidos que le dan una sensaci√≥n acogedora (rojos y naranjas)\n`;
          } else if (avgWarmth < -0.1) {
              description += `‚Ä¢ Los tonos son m√°s bien fr√≠os, con predominio de azules\n`;
          } else {
              description += `‚Ä¢ Los colores est√°n bien balanceados entre c√°lidos y fr√≠os\n`;
          }
          
          if (avgSat < 0.2) {
              description += `‚Ä¢ Los colores son bastante sutiles, casi como un filtro vintage\n`;
          } else if (avgSat > 0.6) {
              description += `‚Ä¢ ¬°Los colores son s√∫per vivos y llamativos!\n`;
          } else {
              description += `‚Ä¢ Los colores se ven naturales, nada exagerado\n`;
          }
          
          description += `‚Ä¢ ${avgColor > 50 ? 'Hay mucha variedad de colores' : avgColor > 25 ? 'Tiene una buena variedad de colores' : 'La paleta de colores es m√°s bien simple'}\n`;
          
          // Opini√≥n m√°s personal y amigable
          description += `\nüéØ Mi opini√≥n personal:\n`;
          
          if (type === 'retrato') {
              description += `Creo que quedar√≠a genial con un toque m√°s suave para que la piel se vea mejor. `;
          } else if (type === 'paisaje' || type === 'cielo') {
              description += `¬°Tiene mucho potencial! Podr√≠amos hacer que los colores naturales resalten m√°s. `;
          } else if (type === 'nocturna') {
              description += `Me encanta la atm√≥sfera nocturna, podr√≠amos jugar con efectos creativos. `;
          }
          
          if (avgBrightness < 100) {
              description += `Tal vez podr√≠amos iluminar algunas partes para que se vea mejor. `;
          }
          if (avgSat < 0.3) {
              description += `Los colores podr√≠an ser un poquito m√°s vivos. `;
          }
          
          description += `\nüí° *Si quieres que te d√© consejos espec√≠ficos, solo dime "recomendaci√≥n" o "analiza"*`;
          
          return description;
      }
      
      // Comandos avanzados de procesamiento por lotes
      if (msg.includes('lote') || msg.includes('batch') || msg.includes('todas las im√°genes')) {
          return "üì¶ **Procesamiento por lotes**: Actualmente trabajo con una imagen a la vez, pero puedo ayudarte a crear un preset que apliques a m√∫ltiples fotos. ¬øQuieres que analice esta imagen y cree un preset reutilizable?";
      }
      
      // Comandos de comparaci√≥n inteligente
      if (msg.includes('compara') || msg.includes('diferencia') || msg.includes('antes y despu√©s')) {
          return "üîÑ **Comparaci√≥n**: Mant√©n presionado el bot√≥n 'Antes/Despu√©s' para ver la imagen original. Tambi√©n puedo generar un an√°lisis de los cambios aplicados. ¬øQuieres que compare el estado actual con la imagen original?";
      }
      
      // Control directo de herramientas
      if (msg.includes('histograma') || msg.includes('distribuci√≥n tonal')) {
          return "üìä **An√°lisis del histograma**: Veo el histograma en tiempo real en la esquina superior derecha del canvas. Puedo interpretarlo: picos a la izquierda = sombras, centro = medios tonos, derecha = luces. ¬øQuieres que analice la distribuci√≥n tonal actual?";
      }
      
      if (msg.includes('curvas') || msg.includes('control tonal') || msg.includes('curve')) {
          return "üìà **Editor de curvas**: Usa el panel de curvas tonales a la derecha. Haz clic para a√±adir puntos, arrastra para ajustar, doble clic para eliminar. Curva en S = m√°s contraste. ¬øQuieres que configure una curva espec√≠fica?";
      }
      
      // Comandos de recomendaci√≥n inteligente (con botones de acci√≥n)
      if (msg.includes('recomendaci√≥n') || msg.includes('recomendacion') || msg.includes('analiza') || msg.includes('sugiere') || msg.includes('recomienda')) {
          const recommendation = analyzeImageForRecommendation();
          if (recommendation) {
              sessionStats.imagesAnalyzed++; // Actualizar estad√≠sticas
              pendingRecommendation = recommendation;
              
              let responseText = recommendation.text;
              if(recommendation.isPersonalized) {
                  responseText += "\n\nüß† *Recomendaci√≥n personalizada basada en tus preferencias anteriores*";
              }
              
              return {
                  text: responseText,
                  isRecommendation: true,
                  preset: recommendation.preset
              };
          }
          return "Oye, necesito que subas una imagen primero para poder analizarla y darte buenos consejos üòä";
      }
      
      // Sugerencias inteligentes autom√°ticas
      if (msg.includes('sugerencia autom√°tica') || msg.includes('auto suggest') || msg.includes('sugerencias')) {
          if(!appState.image.instance.complete) {
              return "Necesito una imagen cargada para generar sugerencias autom√°ticas üì∏";
          }
          
          const suggestions = generateSmartSuggestions();
          return `üí° **Sugerencias inteligentes**:\n${suggestions.join('\n')}\n\n¬øTe interesa alguna de estas opciones?`;
      }
      
      // Comandos profesionales de edici√≥n
      if (msg.includes('workflow') || msg.includes('flujo de trabajo') || msg.includes('profesional')) {
          return "‚ö° **Flujo profesional**: Para edici√≥n eficiente: 1) Correcci√≥n de exposici√≥n, 2) Balance de blancos, 3) Ajuste de sombras/luces, 4) Saturaci√≥n selectiva, 5) Nitidez final. ¬øEn qu√© paso necesitas ayuda?";
      }
      if (msg.includes('calibraci√≥n') || msg.includes('color management') || msg.includes('perfil de color')) {
          return "üéØ **Gesti√≥n de color**: Para precisi√≥n profesional, aseg√∫rate de: temperatura correcta (5500K-6500K para luz d√≠a), tinte neutro, y blancos puros. Usa el histograma para evitar clipping. ¬øTrabajas con un perfil de color espec√≠fico?";
      }
      if (msg.includes('lightroom') || msg.includes('adobe') || msg.includes('xmp')) {
          return "üìÅ **Compatibilidad Lightroom**: Puedes exportar tus ajustes como archivos XMP compatibles con Lightroom. Los valores se mapean directamente: Exposici√≥n, Contraste, Luces, Sombras, etc. ¬øQuieres exportar tu preset actual?";
      }
      if (msg.includes('raw') || msg.includes('procesado') || msg.includes('revelado')) {
          return "üì∏ **Procesado RAW**: Aunque trabajo con JPEG, simulo el flujo RAW: recuperaci√≥n de luces (-100 a -50), levantamiento de sombras (+30 a +80), claridad para detalles, y vibrance para colores naturales. ¬øQu√© aspecto quieres mejorar?";
      }
      if (msg.includes('curvas') || msg.includes('tonales') || msg.includes('contraste selectivo')) {
          return "üìà **Curvas tonales**: Usa el editor de curvas para control preciso. Curva en S para contraste, levantar sombras sin afectar negros, bajar luces preservando blancos. Haz clic en la curva para a√±adir puntos de control.";
      }
      if (msg.includes('tutorial') || msg.includes('aprende') || msg.includes('ense√±a')) {
          sessionStats.tutorialsViewed++;
          return "üéì **Tutorial profesional interactivo**: \n\n**Comandos b√°sicos:**\n‚Ä¢ 'recomendaci√≥n' - An√°lisis IA de tu imagen\n‚Ä¢ 'que ves' - Descripci√≥n detallada\n‚Ä¢ 'histograma' - An√°lisis tonal\n‚Ä¢ 'curvas' - Control de curvas\n\n**Comandos avanzados:**\n‚Ä¢ 'workflow' - Flujo profesional\n‚Ä¢ 'calibraci√≥n' - Gesti√≥n de color\n‚Ä¢ 'lightroom' - Compatibilidad XMP\n‚Ä¢ 'raw' - T√©cnicas de procesado\n‚Ä¢ 'lote' - Procesamiento m√∫ltiple\n\n**Estilos r√°pidos:**\n‚Ä¢ 'retrato/paisaje/nocturna' - Optimizaci√≥n por tipo\n‚Ä¢ 'vintage/dram√°tico/suave' - Presets art√≠sticos\n\n**Tutoriales espec√≠ficos:**\n‚Ä¢ 'tutorial retrato' - Edici√≥n de retratos paso a paso\n‚Ä¢ 'tutorial paisaje' - T√©cnicas para paisajes\n‚Ä¢ 'tutorial curvas' - Dominar las curvas tonales\n\n¬øQu√© t√©cnica quieres dominar? Puedo darte un tutorial paso a paso.";
      }
      
      // Tutoriales interactivos espec√≠ficos
      if (msg.includes('tutorial retrato') || msg.includes('aprende retrato')) {
          return "üë§ **Tutorial: Edici√≥n de Retratos**\n\n**Paso 1**: Suavizar piel con Claridad (-10 a -20)\n**Paso 2**: Calentar tonos con Temperatura (+5 a +15)\n**Paso 3**: Levantar Sombras (+15 a +25) para iluminar rostro\n**Paso 4**: A√±adir Vibrance (+10 a +20) para colores naturales\n**Paso 5**: Reducir Highlights (-5 a -15) si hay brillos\n\nüí° *Tip profesional*: Evita saturaci√≥n alta en retratos, usa Vibrance.\n\n¬øQuieres que aplique estos ajustes a tu imagen?";
      }
      
      if (msg.includes('tutorial paisaje') || msg.includes('aprende paisaje')) {
          return "üåÑ **Tutorial: Edici√≥n de Paisajes**\n\n**Paso 1**: Aumentar Contraste (+15 a +25) para definici√≥n\n**Paso 2**: A√±adir Vibrance (+20 a +35) para colores naturales\n**Paso 3**: Subir Claridad (+10 a +20) para detalles\n**Paso 4**: Ajustar Luces/Sombras seg√∫n iluminaci√≥n\n**Paso 5**: Usar curvas para contraste selectivo\n\nüí° *Tip profesional*: En paisajes, el cielo y primer plano necesitan ajustes diferentes.\n\n¬øAnalizo tu paisaje y aplico estos principios?";
      }
      
      if (msg.includes('tutorial curvas') || msg.includes('aprende curvas')) {
          return "üìà **Tutorial: Curvas Tonales**\n\n**Conceptos b√°sicos:**\n‚Ä¢ Eje X = Entrada (0-255)\n‚Ä¢ Eje Y = Salida (0-255)\n‚Ä¢ L√≠nea diagonal = Sin cambios\n\n**T√©cnicas:**\n‚Ä¢ **Curva S**: Sube luces, baja sombras = m√°s contraste\n‚Ä¢ **Levantar sombras**: Punto en zona oscura hacia arriba\n‚Ä¢ **Bajar luces**: Punto en zona clara hacia abajo\n\n**Controles:**\n‚Ä¢ Clic = A√±adir punto\n‚Ä¢ Arrastrar = Ajustar\n‚Ä¢ Doble clic = Eliminar\n\n**Presets disponibles:**\n‚Ä¢ Lineal, S Suave, S Fuerte, Pel√≠cula\n\n¬øQuieres que configure una curva espec√≠fica en tu imagen?";
      }
      if (msg.includes('historial') || msg.includes('conversaciones') || msg.includes('history')) {
          const historyCount = conversationHistory.length;
          const recentStyles = conversationHistory.slice(-5).filter(h => h.sender === 'user').map(h => h.text).join(', ');
          
          return `üìä **Sesi√≥n de trabajo detallada**:\n\n**Actividad actual:**\n‚Ä¢ Consultas realizadas: ${sessionStats.messagesCount}\n‚Ä¢ Im√°genes procesadas: ${sessionStats.imagesAnalyzed}\n‚Ä¢ Ajustes aplicados: ${sessionStats.presetsApplied}\n‚Ä¢ Comandos ejecutados: ${sessionStats.commandsExecuted}\n\n**Historial:**\n‚Ä¢ Conversaciones guardadas: ${historyCount}\n‚Ä¢ Estilos recientes: ${recentStyles || 'Ninguno a√∫n'}\n\n**Aprendizaje:**\n‚Ä¢ Patrones detectados: ${Object.keys(learningData.stylePreferences).length}\n‚Ä¢ Sesiones totales: ${userPreferences.totalSessions || 1}\n\n¬øNecesitas limpiar el historial o continuar trabajando?`;
      }
      if (msg.includes('estad√≠sticas') || msg.includes('stats') || msg.includes('m√©tricas') || msg.includes('rendimiento')) {
          const totalPresets = Object.keys(getPresets()).length;
          const efficiency = sessionStats.messagesCount > 0 ? Math.round((sessionStats.presetsApplied / sessionStats.messagesCount) * 100) : 0;
          const learningProgress = Object.keys(learningData.stylePreferences).length;
          
          return `üìà **M√©tricas de productividad avanzadas**:\n\n**Rendimiento:**\n‚Ä¢ Presets desarrollados: ${totalPresets}\n‚Ä¢ Eficiencia de sesi√≥n: ${efficiency}% (${sessionStats.presetsApplied}/${sessionStats.messagesCount})\n‚Ä¢ Comandos ejecutados: ${sessionStats.commandsExecuted}\n‚Ä¢ An√°lisis realizados: ${sessionStats.imagesAnalyzed}\n\n**Inteligencia:**\n‚Ä¢ Preferencias aprendidas: ${learningProgress} patrones\n‚Ä¢ Cache de an√°lisis: ${imageAnalysisCache.size} im√°genes\n‚Ä¢ Precisi√≥n personalizada: ${learningProgress > 5 ? 'Alta' : learningProgress > 2 ? 'Media' : 'B√°sica'}\n\n**Estado:** ${appState.image.instance.complete ? 'Imagen activa ‚úÖ' : 'Sin imagen ‚è≥'}\n\nüöÄ *Tip: M√°s uso = Recomendaciones m√°s precisas*`;
      }
      if (msg.includes('limpiar') || msg.includes('borrar historial') || msg.includes('reset chat')) {
          conversationHistory = [];
          localStorage.removeItem('chatHistory');
          sessionStats = { messagesCount: 0, imagesAnalyzed: 0, presetsApplied: 0, commandsExecuted: 0, tutorialsViewed: 0 };
          return "üßπ **Historial limpiado**: He borrado todas las conversaciones anteriores. ¬°Empezamos de nuevo! ¬øEn qu√© puedo ayudarte?";
      }
      
      if (msg.includes('reset completo') || msg.includes('borrar todo') || msg.includes('limpiar datos')) {
          conversationHistory = [];
          learningData = { stylePreferences: {}, frequentAdjustments: {}, imageTypes: {} };
          userPreferences = {};
          imageAnalysisCache.clear();
          sessionStats = { messagesCount: 0, imagesAnalyzed: 0, presetsApplied: 0, commandsExecuted: 0, tutorialsViewed: 0 };
          
          localStorage.removeItem('chatHistory');
          localStorage.removeItem('learningData');
          localStorage.removeItem('userPreferences');
          
          return "üîÑ **Reset completo realizado**: He borrado todo el historial, preferencias aprendidas y datos de sesi√≥n. Empezamos completamente de cero. ¬°Hola! ¬øEn qu√© puedo ayudarte?";
      }
      
      // An√°lisis espec√≠fico por tipo de fotograf√≠a
      if (msg.includes('retrato') || msg.includes('persona') || msg.includes('cara')) {
          return "üë§ ¬°Ah, los retratos! Me encantan. Para que se vea bien la piel, te recomiendo bajar un poco la claridad (como -10 o -20), calentar los tonos (+5 a +15), levantar las sombras (+15 a +25) y darle un toque de vibrance (+10 a +20). ¬øQuieres que mire tu foto y te d√© consejos m√°s espec√≠ficos?";
      }
      if (msg.includes('paisaje') || msg.includes('naturaleza') || msg.includes('cielo')) {
          return "üåÑ ¬°Los paisajes son lo m√≠o! Para que se vean espectaculares, me gusta subir el contraste (+15 a +25), darle vibrance a los colores (+20 a +35), a√±adir claridad para los detalles (+10 a +20) y jugar con las luces y sombras seg√∫n c√≥mo est√© la iluminaci√≥n. ¬øTe echo un vistazo a tu imagen?";
      }
      if (msg.includes('nocturna') || msg.includes('noche') || msg.includes('oscura')) {
          return "üåô ¬°Las fotos nocturnas tienen tanto misterio! Para que se vean geniales, suelo levantar bastante las sombras (+30 a +50), cuidar que no haya mucho ruido, darle contraste moderado (+15 a +25) y no exagerar con los colores. ¬øQuieres que analice tu foto nocturna?";
      }
      if (msg.includes('macro') || msg.includes('detalle') || msg.includes('textura')) {
          return "üîç ¬°Me fascinan los detalles! Para fotos macro o de texturas, me gusta subir bastante la claridad (+20 a +40), aumentar la nitidez (+10 a +25), jugar con el contraste local y ser selectivo con el vibrance. ¬øAnalizo los detalles de tu imagen?";
      }
      if (msg.includes('balance de blancos') || msg.includes('temperatura de color') || msg.includes('kelvin')) {
          return "üå°Ô∏è **Balance de blancos**: Para precisi√≥n profesional: Luz d√≠a (5500K) = temperatura neutra, Tungsteno (3200K) = +temperatura, Sombra (7000K) = -temperatura. Ajusta tinte para magenta/verde. ¬øQu√© iluminaci√≥n ten√≠a tu foto?";
      }
      if (msg.includes('exposici√≥n') || msg.includes('clipping') || msg.includes('sobreexposici√≥n')) {
          return "üìâ **Control de exposici√≥n**: Usa el histograma para detectar clipping. Si hay p√©rdida en luces: baja highlights (-50 a -100), si hay p√©rdida en sombras: sube shadows (+30 a +80). Mantener detalle es clave.";
      }
      if (msg.includes('nitidez') || msg.includes('enfoque') || msg.includes('sharpening')) {
          return "‚öîÔ∏è **Nitidez profesional**: Para output final: Cantidad (25-150), Radio (0.5-2.0), Detalle (25), Enmascarado (0). Para web: m√°s cantidad, para impresi√≥n: m√°s radio. ¬øEs para pantalla o impresi√≥n?";
      }
      if (msg.includes('ruido') || msg.includes('iso alto') || msg.includes('grain')) {
          return "üîá **Reducci√≥n de ruido**: Para ISO alto: Reducci√≥n de ruido (20-60), preservar detalles finos. El grano de pel√≠cula puede a√±adir car√°cter art√≠stico. ¬øLa foto es de ISO alto o quieres efecto vintage?";
      }
      if (msg.includes('hsl') || msg.includes('color selectivo') || msg.includes('saturaci√≥n selectiva')) {
          return "üåà **Color selectivo**: Ajusta colores espec√≠ficos sin afectar otros. Rojos para piel, verdes para follaje, azules para cielo. Usa Matiz para cambiar color, Saturaci√≥n para intensidad, Luminancia para brillo.";
      }
      
      const responses = {
        'hola': '¬°Hola! üëã Soy tu asistente para editar fotos. Me encanta ayudar a que tus im√°genes se vean incre√≠bles. Puedo mirar tu foto y decirte qu√© le har√≠a falta, o si prefieres, solo dime "que ves" y te cuento lo que observo.',
        'hi': '¬°Hi! üëã I\'m here to help make your photos look amazing! I can analyze your image or help with specific styles. Just ask!',
        'hello': '¬°Hello! üëã Ready to make some beautiful edits? I can look at your photo and suggest improvements, or help with any style you want.',
        'buenos d√≠as': '¬°Buenos d√≠as! ‚òÄÔ∏è ¬øQu√© tal si empezamos editando alguna foto? Puedo ayudarte con el estilo que quieras o analizar lo que ya tienes.',
        'buenas tardes': '¬°Buenas tardes! üåÖ ¬øTienes alguna foto que quieras mejorar? Me encanta ayudar con la edici√≥n.',
        'buenas noches': '¬°Buenas noches! üåô Perfecto momento para editar fotos. ¬øEn qu√© puedo ayudarte?',
        'gracias': '¬°De nada! üòä Me encanta ayudar. ¬øHay algo m√°s que quieras hacer con tus fotos?',
        'thanks': 'You\'re so welcome! üòä I love helping with photos. Anything else you\'d like to try?',
        'adi√≥s': '¬°Hasta luego! üëã Espero que tus fotos queden preciosas.',
        'bye': 'Bye! üëã Hope your photos turn out amazing!',
        'ayuda': 'üéØ **Te puedo ayudar con:**\n‚Ä¢ "recomendaci√≥n" - Miro tu foto y te digo qu√© mejorar\n‚Ä¢ "retrato/paisaje/nocturna" - Consejos para cada tipo\n‚Ä¢ "que ves" - Te describo lo que veo en tu imagen\n‚Ä¢ "tono c√°lido/fr√≠o" - Cambio la temperatura\n‚Ä¢ "vintage/dram√°tico/suave" - Estilos geniales',
        'help': 'üéØ **I can help you with:**\n‚Ä¢ "recommendation" - I\'ll analyze your photo\n‚Ä¢ "portrait/landscape/night" - Tips for each type\n‚Ä¢ "what do you see" - I\'ll describe your image\n‚Ä¢ "warm/cool tone" - Temperature adjustments\n‚Ä¢ "vintage/dramatic/soft" - Cool preset styles',
        '¬øqu√© puedes hacer?': 'üéØ **Lo que puedo hacer por ti:**\n‚Ä¢ Mirar tu foto y reconocer qu√© tipo es\n‚Ä¢ Analizar si est√° muy oscura, muy clara, etc.\n‚Ä¢ Detectar si es retrato, paisaje, macro, etc.\n‚Ä¢ Darte consejos espec√≠ficos para mejorarla\n‚Ä¢ Aplicar autom√°ticamente los ajustes que necesita\n\nSolo dime "recomendaci√≥n" o "que ves" y empezamos.',
        'what can you do': 'üéØ **What I can do for you:**\n‚Ä¢ Look at your photo and recognize what type it is\n‚Ä¢ Analyze if it\'s too dark, bright, etc.\n‚Ä¢ Detect if it\'s portrait, landscape, macro, etc.\n‚Ä¢ Give you specific tips to improve it\n‚Ä¢ Automatically apply the adjustments it needs\n\nJust say "recommendation" or "what do you see" and we\'ll start.'
      };
      
      for (const [key, response] of Object.entries(responses)) {
        if (msg.includes(key)) return response;
      }
      return null;
    }

    const handleChatMessage = async () => {
        const userMessage = dom.chatInput.value.trim();
        if (!userMessage) return;

        addMessageToChat(userMessage, 'user');
        dom.chatInput.value = '';
        
        // Verificar si es una respuesta simple
        const simpleResponse = getSimpleResponse(userMessage);
        if (simpleResponse) {
            addMessageToChat('', 'bot', true);
            setTimeout(() => {
                const typingIndicator = document.getElementById('typingIndicator');
                if (typingIndicator) typingIndicator.remove();
                
                if (typeof simpleResponse === 'object' && simpleResponse.isRecommendation) {
                    addMessageWithActions(simpleResponse.text, true, simpleResponse.preset);
                } else {
                    addMessageToChat(simpleResponse, 'bot');
                }
                
                // Input disponible para continuar la conversaci√≥n
            }, 800);
            return;
        }

        addMessageToChat('', 'bot', true);

        try {
            const values = await callAi(userMessage);
            applyPreset(values);
            learnFromUserAction('preset_applied', values); // Aprender de la acci√≥n
            sessionStats.commandsExecuted++;
            log('Resultado IA', JSON.stringify(values));
            addMessageToChat('¬°Perfecto! He ajustado los controles seg√∫n tu solicitud.', 'bot');
        } catch (e) {
            log('Error IA', e);
            let errorMsg = `Lo siento, ocurri√≥ un error: ${e.message}`;
            if (e.message.includes('429')) {
                errorMsg += ' Has alcanzado el l√≠mite de solicitudes. Espera unos minutos antes de intentar de nuevo.';
            }
            addMessageToChat(errorMsg, 'bot');
        } finally {
            const typingIndicator = document.getElementById('typingIndicator');
            if (typingIndicator) typingIndicator.remove();
            // Input disponible para continuar la conversaci√≥n
        }
    };
    // ===== FIN DE LA L√ìGICA MODIFICADA =====

    // --- Inicializaci√≥n del Sistema de Control de Colores ---
    const initColorControls = () => {
        // Usar el sistema profesional de Lightroom
        const ColorSystemClass = window.LightroomColorSystem || window.ColorControlSystemFixed || window.ColorControlSystem;
        
        if (ColorSystemClass) {
            colorSystem = new ColorSystemClass();
            colorSystem.init(null, () => {
                requestAnimationFrame(() => {
                    scheduleDraw(false);
                });
            });
            console.log('Professional Lightroom color system initialized');
        }
    };
    
    // --- Inicializaci√≥n ---
    const initSliders = () => {
        SLIDERS_CONFIG.forEach(cfg => {
            const row = document.createElement('div');
            row.className = 'slider-row';

            const label = document.createElement('label');
            label.className = 'label';
            label.setAttribute('for', `slider-${cfg.id}`);
            label.textContent = cfg.label;

            const input = document.createElement('input');
            Object.assign(input, { type: 'range', id: `slider-${cfg.id}`, min: cfg.min, max: cfg.max, step: cfg.step, value: cfg.def });
            
            const valueDisplay = document.createElement('div');
            valueDisplay.className = 'value';
            valueDisplay.textContent = cfg.def;

            const resetBtn = document.createElement('button');
            resetBtn.className = 'reset-btn';
            resetBtn.title = 'Reiniciar';
            resetBtn.innerHTML = '‚Ü∫';
            
            row.append(label, input, valueDisplay, resetBtn);
            dom.slidersContainer.appendChild(row);

            appState.ui.sliders[cfg.id] = input;
            appState.ui.displays[cfg.id] = valueDisplay;
            appState.sliderValues[cfg.id] = cfg.def;

            let sliderTimeout = null;
            input.addEventListener('input', () => {
                const value = cfg.step < 1 ? Number(input.value).toFixed(1) : input.value;
                appState.sliderValues[cfg.id] = value;
                valueDisplay.textContent = value;
                
                // Actualizaci√≥n inmediata del valor visual, procesamiento diferido
                if(sliderTimeout) clearTimeout(sliderTimeout);
                sliderTimeout = setTimeout(() => scheduleDraw(), 100); // M√°s tiempo para evitar lag
            });
            resetBtn.addEventListener('click', () => {
                input.value = cfg.def;
                appState.sliderValues[cfg.id] = cfg.def;
                valueDisplay.textContent = cfg.def;
                scheduleDraw(true); // Inmediato para reset
            });
        });
    };
    const initEventListeners = () => {
        let resetTimeout = null, randomTimeout = null;
        dom.resetAll.addEventListener('click',()=>{
            if(resetTimeout) clearTimeout(resetTimeout);
            SLIDERS_CONFIG.forEach(cfg=>{
                const slider = appState.ui.sliders[cfg.id];
                const display = appState.ui.displays[cfg.id];
                slider.value = cfg.def;
                appState.sliderValues[cfg.id] = cfg.def;
                display.textContent = cfg.def;
            });
            resetTimeout = setTimeout(() => scheduleDraw(true), 0);
        });
        dom.randomAll.addEventListener('click',()=>{
            if(randomTimeout) clearTimeout(randomTimeout);
            SLIDERS_CONFIG.forEach(cfg=>{
                const r=Math.random();
                const value = parseFloat(cfg.min)+r*(parseFloat(cfg.max)-parseFloat(cfg.min));
                const slider = appState.ui.sliders[cfg.id];
                const display = appState.ui.displays[cfg.id];
                slider.value = value;
                appState.sliderValues[cfg.id] = value;
                display.textContent = cfg.step < 1 ? Number(value).toFixed(1) : Math.round(value);
            });
            randomTimeout = setTimeout(() => scheduleDraw(true), 0);
        });
        dom.savePreset.addEventListener('click',()=>{const name=(dom.presetName.value||`Preset-${Date.now()}`).replace(/[^\w\-]+/g,'_');const presets=getPresets();presets[name]={...appState.sliderValues};savePresets(presets);alert(`Preset guardado: ${name}`);});
        dom.downloadXmp.addEventListener('click',()=>{const name=(dom.presetName.value||'PresetIA').replace(/[^\w\-]+/g,'_');const xml=buildXmp(name,appState.sliderValues,dom.xmpMode.value);const blob=new Blob([xml],{type:'application/xml'});const a=document.createElement('a');a.href=URL.createObjectURL(blob);a.download=name+'.xmp';a.click();URL.revokeObjectURL(a.href);});
        dom.loadUrl.addEventListener('click',()=>{if(dom.imageUrl.value.trim()){appState.image.gallery.push(dom.imageUrl.value.trim());appState.image.currentIndex=appState.image.gallery.length-1;loadImage(appState.image.gallery[appState.image.currentIndex]);}});
        dom.fileInput.addEventListener('change',(e)=>{const f=e.target.files[0];if(f){const r=new FileReader();r.onload=()=>{appState.image.gallery.push(r.result);appState.image.currentIndex=appState.image.gallery.length-1;loadImage(r.result);};r.readAsDataURL(f);}});
        dom.randomImage.addEventListener('click',()=>{const randomUrl = `https://picsum.photos/1200/800?random=${Date.now()}`;appState.image.gallery.push(randomUrl);appState.image.currentIndex=appState.image.gallery.length-1;loadImage(randomUrl);});

        dom.downloadImg.addEventListener('click',()=>{const a=document.createElement('a');a.href=dom.canvas.toDataURL('image/png');a.download=(dom.presetName.value||'imagen-procesada')+'.png';a.click();});
        
        // Bot√≥n antes/despu√©s
        dom.beforeAfterBtn.addEventListener('mousedown', () => {
            appState.showingOriginal = true;
            drawPreview();
        });
        dom.beforeAfterBtn.addEventListener('mouseup', () => {
            appState.showingOriginal = false;
            scheduleDraw();
        });
        dom.beforeAfterBtn.addEventListener('mouseleave', () => {
            appState.showingOriginal = false;
            scheduleDraw();
        });
        let curveModeTimeout = null, clarityTimeout = null;
        dom.curveMode.addEventListener('input', () => {
            if(curveModeTimeout) clearTimeout(curveModeTimeout);
            curveModeTimeout = setTimeout(() => scheduleDraw(), 100);
        });
        dom.clarityIntensity.addEventListener('input', () => {
            if(clarityTimeout) clearTimeout(clarityTimeout);
            clarityTimeout = setTimeout(() => scheduleDraw(), 100);
        });

        
        // Eventos del chatbot modal
        dom.aiToggleBtn.addEventListener('click', () => {
            dom.chatModal.classList.toggle('show');
        });
        dom.chatClose.addEventListener('click', () => {
            dom.chatModal.classList.remove('show');
        });
        
        // Bot√≥n de estad√≠sticas mejorado
        const chatStatsBtn = document.getElementById('chatStats');
        if (chatStatsBtn) {
            chatStatsBtn.addEventListener('click', () => {
                const totalPresets = Object.keys(getPresets()).length;
                const learningStats = Object.keys(learningData.stylePreferences).length;
                const cacheSize = imageAnalysisCache.size;
                
                const statsMessage = `üìà **Estad√≠sticas avanzadas**:\n\n**Sesi√≥n actual:**\n‚Ä¢ Mensajes: ${sessionStats.messagesCount}\n‚Ä¢ Im√°genes analizadas: ${sessionStats.imagesAnalyzed}\n‚Ä¢ Presets aplicados: ${sessionStats.presetsApplied}\n‚Ä¢ Comandos ejecutados: ${sessionStats.commandsExecuted}\n‚Ä¢ Tutoriales vistos: ${sessionStats.tutorialsViewed}\n\n**Datos guardados:**\n‚Ä¢ Presets creados: ${totalPresets}\n‚Ä¢ Conversaciones: ${conversationHistory.length}\n‚Ä¢ Preferencias aprendidas: ${learningStats}\n‚Ä¢ Cache de an√°lisis: ${cacheSize} im√°genes\n\n**Sesiones totales:** ${userPreferences.totalSessions || 1}`;
                addMessageToChat(statsMessage, 'bot');
            });
        }
        
        // Cerrar modal al hacer clic fuera
        document.addEventListener('click', (e) => {
            if (!dom.chatModal.contains(e.target) && !dom.aiToggleBtn.contains(e.target)) {
                dom.chatModal.classList.remove('show');
            }
        });
        
        dom.chatSendBtn.addEventListener('click', handleChatMessage);
        dom.chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                handleChatMessage();
            }
        });
        
        // Auto-sugerencias inteligentes
        dom.chatInput.addEventListener('input', (e) => {
            const value = e.target.value.toLowerCase();
            if(value.length > 2) {
                generateAutoSuggestions(value);
            }
        });
        
        // Limpiar cache peri√≥dicamente
        setInterval(cleanupCache, 300000); // Cada 5 minutos
        
        // Curvas optimizadas
        dom.resetCurves.addEventListener('click', () => {
            curveState.channels[curveState.currentChannel] = [{x: 0, y: 0}, {x: 255, y: 255}];
            curveCache.dirty[curveState.currentChannel] = true;
            drawCurves(); scheduleDraw(true);
        });
        
        // Bot√≥n para reiniciar todas las curvas
        dom.resetAllCurves.addEventListener('click', () => {
            if(confirm('¬øEst√°s seguro de que quieres reiniciar todas las curvas tonales?')) {
                // Reiniciar todos los canales
                Object.keys(curveState.channels).forEach(channel => {
                    curveState.channels[channel] = [{x: 0, y: 0}, {x: 255, y: 255}];
                    curveCache.dirty[channel] = true;
                });
                drawCurves(); 
                scheduleDraw(true);
            }
        });
        dom.autoContrast.addEventListener('click', () => {
            curveState.channels[curveState.currentChannel] = [{x: 0, y: 0}, {x: 64, y: 45}, {x: 128, y: 128}, {x: 192, y: 210}, {x: 255, y: 255}];
            curveCache.dirty[curveState.currentChannel] = true;
            drawCurves(); scheduleDraw(true);
        });
        
        const mediumContrastBtn = document.getElementById('curveMediumContrast');
        if(mediumContrastBtn) {
            mediumContrastBtn.addEventListener('click', () => {
                curveState.channels[curveState.currentChannel] = [{x: 0, y: 0}, {x: 85, y: 75}, {x: 170, y: 180}, {x: 255, y: 255}];
                curveCache.dirty[curveState.currentChannel] = true;
                drawCurves(); scheduleDraw(true);
            });
        }
        
        // Nuevos controles optimizados con displays de valores
        const advancedControls = [
            { id: 'shadowTint', displayId: 'shadowTintValue' },
            { id: 'highlightTint', displayId: 'highlightTintValue' },
            { id: 'sharpenAmount', displayId: 'sharpenAmountValue' },
            { id: 'sharpenRadius', displayId: 'sharpenRadiusValue' },
            { id: 'noiseReduction', displayId: 'noiseReductionValue' },
            { id: 'filmGrain', displayId: 'filmGrainValue' },
            { id: 'partialDesaturation', displayId: 'partialDesaturationValue' },
            { id: 'ortonEffect', displayId: 'ortonEffectValue' }
        ];
        
        advancedControls.forEach(({ id, displayId }) => {
            const slider = document.getElementById(id);
            const display = document.getElementById(displayId);
            
            if(slider && display) {
                let inputTimeout = null;
                
                slider.addEventListener('input', () => {
                    const value = slider.step && slider.step !== '1' ? 
                        parseFloat(slider.value).toFixed(1) : 
                        parseInt(slider.value);
                    display.textContent = value;
                    
                    if(inputTimeout) clearTimeout(inputTimeout);
                    inputTimeout = setTimeout(() => scheduleDraw(), 150);
                });
                
                // Inicializar valor
                const initialValue = slider.step && slider.step !== '1' ? 
                    parseFloat(slider.value).toFixed(1) : 
                    parseInt(slider.value);
                display.textContent = initialValue;
            }
        });
        
        // Atajos de teclado profesionales
        document.addEventListener('keydown', (e) => {
            // Evitar atajos cuando se est√° escribiendo
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            
            const key = e.key.toLowerCase();
            
            // Pantalla completa
            if (e.ctrlKey && key === 'f') {
                e.preventDefault();
                toggleFullscreen();
            }
            if (key === 'escape' && document.querySelector('.fullscreen-overlay.show')) {
                toggleFullscreen();
            }
            
            // Zoom con teclado
            if (e.ctrlKey && key === '0') {
                e.preventDefault();
                if (window.zoomSystem) window.zoomSystem.fitToScreen();
            }
            
            // Atajos b√°sicos
            if (e.ctrlKey && key === 'z') {
                e.preventDefault();
                dom.resetAll.click();
            }
            if (e.ctrlKey && key === 'r') {
                e.preventDefault();
                dom.randomAll.click();
            }
            if (e.ctrlKey && key === 's') {
                e.preventDefault();
                dom.downloadImg.click();
            }
            if (e.ctrlKey && key === 'o') {
                e.preventDefault();
                dom.fileInput.click();
            }
            
            // Atajos de ajustes
            if (key === 'e') {
                const slider = appState.ui.sliders.exposure;
                if (slider) {
                    slider.value = e.shiftKey ? Math.max(slider.min, Number(slider.value) - 10) : Math.min(slider.max, Number(slider.value) + 10);
                    slider.dispatchEvent(new Event('input'));
                }
            }
            if (key === 'c') {
                const slider = appState.ui.sliders.contrast;
                if (slider) {
                    slider.value = e.shiftKey ? Math.max(slider.min, Number(slider.value) - 10) : Math.min(slider.max, Number(slider.value) + 10);
                    slider.dispatchEvent(new Event('input'));
                }
            }
            if (key === 's' && !e.ctrlKey) {
                const slider = appState.ui.sliders.saturation;
                if (slider) {
                    slider.value = e.shiftKey ? Math.max(slider.min, Number(slider.value) - 10) : Math.min(slider.max, Number(slider.value) + 10);
                    slider.dispatchEvent(new Event('input'));
                }
            }
            
            // Atajos de paneles
            if (key === 'h') {
                const panel = document.getElementById('imageInfoPanel');
                if (panel) panel.classList.toggle('hidden');
            }
            
            // Chat IA
            if (e.ctrlKey && key === 'i') {
                e.preventDefault();
                dom.aiToggleBtn.click();
            }
            
            // Ayuda
            if (e.ctrlKey && key === '?') {
                e.preventDefault();
                showShortcuts();
            }
        });
        
        // Funci√≥n para mostrar atajos de teclado
        const showShortcuts = () => {
            let modal = document.getElementById('shortcutsModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'shortcutsModal';
                modal.className = 'shortcuts-modal';
                modal.innerHTML = `
                    <div class="shortcuts-content">
                        <div class="shortcuts-header">
                            <h3>‚å®Ô∏è Atajos de Teclado</h3>
                            <button class="close-shortcuts" onclick="document.getElementById('shortcutsModal').classList.remove('show')">√ó</button>
                        </div>
                        <div class="shortcuts-body">
                            <div class="shortcut-section">
                                <h4>B√°sicos</h4>
                                <div class="shortcut-row"><span class="shortcut-desc">Reiniciar ajustes</span><span class="shortcut-key">Ctrl+Z</span></div>
                                <div class="shortcut-row"><span class="shortcut-desc">Valores aleatorios</span><span class="shortcut-key">Ctrl+R</span></div>
                                <div class="shortcut-row"><span class="shortcut-desc">Descargar imagen</span><span class="shortcut-key">Ctrl+S</span></div>
                                <div class="shortcut-row"><span class="shortcut-desc">Abrir archivo</span><span class="shortcut-key">Ctrl+O</span></div>
                                <div class="shortcut-row"><span class="shortcut-desc">Pantalla completa</span><span class="shortcut-key">Ctrl+F</span></div>
                            </div>
                            <div class="shortcut-section">
                                <h4>Ajustes R√°pidos</h4>
                                <div class="shortcut-row"><span class="shortcut-desc">Exposici√≥n +/-</span><span class="shortcut-key">E / Shift+E</span></div>
                                <div class="shortcut-row"><span class="shortcut-desc">Contraste +/-</span><span class="shortcut-key">C / Shift+C</span></div>
                                <div class="shortcut-row"><span class="shortcut-desc">Saturaci√≥n +/-</span><span class="shortcut-key">S / Shift+S</span></div>
                            </div>
                            <div class="shortcut-section">
                                <h4>Paneles</h4>
                                <div class="shortcut-row"><span class="shortcut-desc">Info de imagen</span><span class="shortcut-key">H</span></div>
                                <div class="shortcut-row"><span class="shortcut-desc">Panel de capas</span><span class="shortcut-key">L</span></div>
                                <div class="shortcut-row"><span class="shortcut-desc">Chat IA</span><span class="shortcut-key">Ctrl+I</span></div>
                                <div class="shortcut-row"><span class="shortcut-desc">Esta ayuda</span><span class="shortcut-key">Ctrl+?</span></div>
                            </div>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) modal.classList.remove('show');
                });
            }
            modal.classList.add('show');
        };
        window.showShortcuts = showShortcuts;
    };

    // Sistema de Zoom Profesional Ultra-Fluido
    const initZoomSystem = () => {
        const canvas = document.getElementById('canvas');
        const container = document.querySelector('.canvas-container');
        let isDragging = false;
        let lastX = 0, lastY = 0;
        let currentZoom = 1;
        let zoomAnimationId = null;
        let lastWheelTime = 0;
        
        // Configuraci√≥n profesional
        const ZOOM_SENSITIVITY = 0.1;
        const MIN_ZOOM = 0.5;
        const MAX_ZOOM = 10;
        const ANIMATION_DURATION = 150;
        
        // Transiciones suaves CSS
        canvas.style.transition = 'transform 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
        canvas.style.willChange = 'transform';
        
        const smoothSetZoom = (targetZoom, mouseX = null, mouseY = null, animate = true) => {
            if (zoomAnimationId) {
                cancelAnimationFrame(zoomAnimationId);
            }
            
            const startZoom = currentZoom;
            targetZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, targetZoom));
            
            if (!animate || Math.abs(targetZoom - startZoom) < 0.01) {
                applyZoom(targetZoom, mouseX, mouseY);
                return;
            }
            
            const startTime = performance.now();
            
            const animateZoom = (currentTime) => {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / ANIMATION_DURATION, 1);
                
                // Easing suave
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                const zoom = startZoom + (targetZoom - startZoom) * easeProgress;
                
                applyZoom(zoom, mouseX, mouseY);
                
                if (progress < 1) {
                    zoomAnimationId = requestAnimationFrame(animateZoom);
                }
            };
            
            zoomAnimationId = requestAnimationFrame(animateZoom);
        };
        
        const applyZoom = (zoom, mouseX = null, mouseY = null) => {
            currentZoom = zoom;
            
            // Mantener transformaci√≥n de arrastre existente
            const currentTransform = canvas.style.transform;
            const translateMatch = currentTransform.match(/translate3d\(([^,]+),\s*([^,]+),\s*[^)]+\)/);
            let translateX = 0, translateY = 0;
            if (translateMatch) {
                translateX = parseFloat(translateMatch[1]) || 0;
                translateY = parseFloat(translateMatch[2]) || 0;
            }
            
            canvas.style.transform = `scale3d(${zoom}, ${zoom}, 1) translate3d(${translateX}px, ${translateY}px, 0)`;
            
            if (zoom > 1) {
                container.classList.add('zoomed');
                canvas.style.cursor = 'grab';
            } else {
                container.classList.remove('zoomed');
                canvas.style.cursor = 'default';
                // Resetear posici√≥n cuando zoom = 1
                canvas.style.transform = `scale3d(${zoom}, ${zoom}, 1)`;
            }
        };
        
        // Professional zoom system is now handled by zoom.js
        // This section has been moved to the dedicated zoom module
        
        // Compatibility layer
        window.zoomManager = {
            currentZoom: () => window.zoomSystem ? window.zoomSystem.currentZoom() : 1,
            fitToScreen: () => window.zoomSystem ? window.zoomSystem.fitToScreen() : null,
            actualSize: () => window.zoomSystem ? window.zoomSystem.actualSize() : null,
            zoomIn: () => window.zoomSystem ? window.zoomSystem.zoomIn() : null,
            zoomOut: () => window.zoomSystem ? window.zoomSystem.zoomOut() : null,
            setZoom: (zoom) => window.zoomSystem ? window.zoomSystem.setZoom(zoom) : null
        };
    };
    
    // Pantalla completa con zoom
    const toggleFullscreen = () => {
        let overlay = document.getElementById('fullscreenOverlay');
        
        if (!overlay) {
            overlay = document.createElement('div');
            overlay.id = 'fullscreenOverlay';
            overlay.className = 'fullscreen-overlay';
            
            const canvas = document.createElement('canvas');
            canvas.className = 'fullscreen-canvas';
            
            const info = document.createElement('div');
            info.className = 'fullscreen-info';
            info.innerHTML = 'ESC para salir ‚Ä¢ Scroll para zoom ‚Ä¢ Arrastrar para mover';
            
            overlay.appendChild(canvas);
            overlay.appendChild(info);
            document.body.appendChild(overlay);
            
            // Zoom en pantalla completa
            let fullscreenZoom = 1;
            let isDragging = false;
            let lastX = 0, lastY = 0;
            
            overlay.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const centerX = e.clientX - rect.left;
                const centerY = e.clientY - rect.top;
                
                if (e.deltaY < 0) {
                    fullscreenZoom = Math.min(fullscreenZoom * 1.2, 5);
                } else {
                    fullscreenZoom = Math.max(fullscreenZoom / 1.2, 0.8);
                }
                
                canvas.style.transform = `scale(${fullscreenZoom})`;
            });
            
            canvas.addEventListener('mousedown', (e) => {
                if (fullscreenZoom > 1) {
                    isDragging = true;
                    lastX = e.clientX;
                    lastY = e.clientY;
                    canvas.style.cursor = 'grabbing';
                }
            });
            
            overlay.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - lastX;
                    const deltaY = e.clientY - lastY;
                    const currentTransform = canvas.style.transform;
                    const translateMatch = currentTransform.match(/translate\(([^,]+),\s*([^)]+)\)/);
                    const currentX = translateMatch ? parseFloat(translateMatch[1]) : 0;
                    const currentY = translateMatch ? parseFloat(translateMatch[2]) : 0;
                    
                    canvas.style.transform = `scale(${fullscreenZoom}) translate(${currentX + deltaX}px, ${currentY + deltaY}px)`;
                    lastX = e.clientX;
                    lastY = e.clientY;
                }
            });
            
            overlay.addEventListener('mouseup', () => {
                isDragging = false;
                canvas.style.cursor = 'default';
            });
            
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) toggleFullscreen();
            });
        }
        
        if (overlay.classList.contains('show')) {
            overlay.classList.remove('show');
        } else {
            const canvas = overlay.querySelector('canvas');
            const sourceCanvas = dom.canvas;
            
            canvas.width = sourceCanvas.width;
            canvas.height = sourceCanvas.height;
            canvas.getContext('2d').drawImage(sourceCanvas, 0, 0);
            canvas.style.transform = 'scale(1)';
            
            overlay.classList.add('show');
        }
    };
    
    // Funciones auxiliares para las mejoras
    const generateSmartSuggestions = () => {
        if(!appState.image.instance.complete) return [];
        
        const analysis = analyzeImageForRecommendation();
        if(!analysis) return [];
        
        const suggestions = [];
        
        // Sugerencias basadas en el an√°lisis
        if(analysis.analysis && analysis.analysis.brightness < 100) {
            suggestions.push('‚Ä¢ "iluminar" - Para levantar la exposici√≥n general');
        }
        if(analysis.analysis && analysis.analysis.saturation < 0.3) {
            suggestions.push('‚Ä¢ "colores vibrantes" - Para intensificar los colores');
        }
        if(analysis.imageType && analysis.imageType.type === 'retrato') {
            suggestions.push('‚Ä¢ "suavizar piel" - Para un retrato m√°s favorecedor');
        }
        if(analysis.imageType && analysis.imageType.type === 'paisaje') {
            suggestions.push('‚Ä¢ "paisaje dram√°tico" - Para un efecto m√°s impactante');
        }
        
        // Sugerencias basadas en preferencias aprendidas
        if(learningData.stylePreferences.contrast > 10) {
            suggestions.push('‚Ä¢ "m√°s contraste" - Basado en tus preferencias');
        }
        if(learningData.stylePreferences.temperature > 5) {
            suggestions.push('‚Ä¢ "tono c√°lido" - Estilo que sueles preferir');
        }
        
        return suggestions.length > 0 ? suggestions : ['‚Ä¢ "recomendaci√≥n" - Para an√°lisis autom√°tico', '‚Ä¢ "que ves" - Para descripci√≥n detallada'];
    };
    
    const generateAutoSuggestions = (input) => {
        const suggestions = {
            'ret': 'retrato suave',
            'pai': 'paisaje dram√°tico', 
            'noc': 'nocturna misteriosa',
            'vin': 'vintage cl√°sico',
            'dra': 'dram√°tico intenso',
            'sua': 'suave natural',
            'cal': 'c√°lido acogedor',
            'fri': 'fr√≠o cinematogr√°fico',
            'con': 'contraste alto',
            'sat': 'saturaci√≥n vibrante',
            'cla': 'claridad n√≠tida',
            'som': 'sombras levantadas',
            'luc': 'luces controladas',
            'cur': 'curvas tonales',
            'his': 'histograma an√°lisis',
            'rec': 'recomendaci√≥n inteligente',
            'que': 'que ves en la imagen',
            'ana': 'analiza mi foto',
            'tut': 'tutorial paso a paso'
        };
        
        const match = Object.keys(suggestions).find(key => input.startsWith(key));
        if(match && input.length >= 3) {
            // Mostrar sugerencia visual (opcional)
            dom.chatInput.setAttribute('placeholder', `¬øQuiz√°s: "${suggestions[match]}"?`);
            setTimeout(() => {
                if(dom.chatInput.value.length <= 3) {
                    dom.chatInput.setAttribute('placeholder', 'Describe el estilo que buscas...');
                }
            }, 3000);
        }
    };
    
    // Guardar preferencias del usuario
    const saveUserPreferences = () => {
        userPreferences.lastSession = Date.now();
        userPreferences.totalSessions = (userPreferences.totalSessions || 0) + 1;
        userPreferences.favoriteStyles = learningData.stylePreferences;
        localStorage.setItem('userPreferences', JSON.stringify(userPreferences));
    };
    
    // Limpiar cache peri√≥dicamente
    const cleanupCache = () => {
        if(imageAnalysisCache.size > 10) {
            const entries = Array.from(imageAnalysisCache.entries());
            // Mantener solo los 5 m√°s recientes
            imageAnalysisCache.clear();
            entries.slice(-5).forEach(([key, value]) => {
                imageAnalysisCache.set(key, value);
            });
        }
    };
    
    // --- Arranque ---
    const main = () => {
        getDomElements();
        initSliders();
        // Inicializar controles de color despu√©s de que el DOM est√© listo
        setTimeout(() => {
            console.log('Initializing color controls...');
            console.log('ColorControlSystem available:', !!window.ColorControlSystem);
            initColorControls();
            
            // Bot√≥n para reiniciar todos los colores
            const resetAllColorsBtn = document.getElementById('resetAllColors');
            if (resetAllColorsBtn) {
                resetAllColorsBtn.addEventListener('click', () => {
                    if (colorSystem) {
                        console.log('Resetting color system');
                        colorSystem.reset();
                        scheduleDraw(true);
                    } else {
                        console.error('Color system not available for reset');
                    }
                });
            }
        }, 100);
        initEventListeners();
        initCurves();
        initZoomSystem();

        loadImage(appState.image.gallery[appState.image.currentIndex]);
        
        // Limpiar cache al inicio
        cleanupCache();
        
        // Mensaje de bienvenida personalizado
        setTimeout(() => {
            const isReturningUser = userPreferences.totalSessions > 1;
            const welcomeMsg = isReturningUser ? 
                `¬°Hola de nuevo! üëã Veo que ya has usado el editor ${userPreferences.totalSessions} veces. Sube una imagen y te dar√© recomendaciones personalizadas basadas en tus preferencias anteriores üòä` :
                '¬°Hola! üëã Soy tu asistente para editar fotos. Sube una imagen y dime qu√© estilo buscas, o simplemente preg√∫ntame "que ves" y te contar√© lo que observo en tu foto üòä';
            
            addMessageToChat(welcomeMsg, 'bot');
            
            setTimeout(() => {
                addMessageToChat('‚ö° **Modo profesional activado**: Tengo conocimientos avanzados en workflow, gesti√≥n de color, curvas tonales y compatibilidad Lightroom. Escribe "tutorial" para ver t√©cnicas profesionales.', 'bot');
                
                if(isReturningUser && Object.keys(learningData.stylePreferences).length > 0) {
                    setTimeout(() => {
                        const topPreference = Object.entries(learningData.stylePreferences)
                            .sort(([,a], [,b]) => Math.abs(b) - Math.abs(a))[0];
                        if(topPreference && Math.abs(topPreference[1]) > 5) {
                            addMessageToChat(`üß† **Preferencia detectada**: Noto que sueles preferir ajustes de ${topPreference[0]}. Tendr√© esto en cuenta en mis recomendaciones.`, 'bot');
                        }
                    }, 2000);
                }
            }, 1500);
        }, 500);
        
        // Guardar preferencias al cerrar
        window.addEventListener('beforeunload', () => {
            saveUserPreferences();
            cleanupCache();
        });
    };
    main();
    
    // === INTEGRACI√ìN DE SISTEMAS PROFESIONALES ===
    
    // Sobrescribir drawPreview para usar Web Workers cuando est√© disponible
    let originalDrawPreview = drawPreview;
    window.drawPreview = () => {
      if (imageWorker && appState.image.instance.complete) {
        try {
          showProcessingIndicator();
          
          const canvas = document.createElement('canvas');
          canvas.width = dom.canvas.width;
          canvas.height = dom.canvas.height;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(appState.image.instance, 0, 0, canvas.width, canvas.height);
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          
          imageWorker.postMessage({
            type: 'process',
            data: {
              imageData: imageData,
              adjustments: appState.sliderValues
            }
          });
        } catch (error) {
          console.warn('Worker postMessage error:', error);
          imageWorker = null;
          originalDrawPreview();
        }
      } else {
        originalDrawPreview();
        
        // Actualizar histograma profesional
        if (window.updateProfessionalHistogram) {
          window.updateProfessionalHistogram();
        }
      }
    };
    
    // Mejorar la funci√≥n de carga de imagen
    let originalLoadImage = loadImage;
    window.loadImage = (src) => {
      return originalLoadImage(src).then(() => {
        if (window.layerSystem) {
          const baseLayer = window.layerSystem.layers[0];
          if (baseLayer && baseLayer.canvas) {
            baseLayer.canvas.width = dom.canvas.width;
            baseLayer.canvas.height = dom.canvas.height;
            const ctx = baseLayer.canvas.getContext('2d');
            ctx.drawImage(appState.image.instance, 0, 0, dom.canvas.width, dom.canvas.height);
          }
        }
        
        if (window.zoomManager) {
          window.zoomManager.fitToScreen();
        }
      });
    };
    
  });
  </script>
</body>
</html>